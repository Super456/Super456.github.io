import{j as l,b as p,c as h,L as n,s,f as t,g as k,aa as i,G as e}from"./chunks/framework.BdPFiiJb.js";const S=JSON.parse('{"title":"Vue3 学习笔记（一）","description":"","frontmatter":{"title":"Vue3 学习笔记（一）","date":"2023-12-23T20:00:00.000Z","tag":["Vue"],"categories":["前端进击"]},"headers":[],"relativePath":"posts/growth-record/frame/vue/vue3-study-01.md","filePath":"posts/growth-record/frame/vue/vue3-study-01.md","lastUpdated":1713608019000}'),E={name:"posts/growth-record/frame/vue/vue3-study-01.md"},r=i("",4),d=i("",30),g=s("li",null,"与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型(如 Map) 中的元素被访问时，它不会被解包",-1),y=i("",84),F=i("",47),c=i("",167),o=i("",15),A=i("",7),u=i("",14),D=s("p",null,[t("注意⚠️：虽然这里的 "),s("code",null,"<Footer>"),t(" 组件可能根本不关心这些 props，但为了使 "),s("code",null,"<DeepChild>"),t(" 能访问到它们，仍然需要定义并向下传递。"),s("strong",null,"如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是希望尽量避免的情况")],-1),C=s("p",null,[s("code",null,"provide"),t(" 和 "),s("code",null,"inject"),t(" 可以帮助我们解决这一问题。 "),s("strong",null,"一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖：")],-1),v=i("",41);function m(B,b,f,q,_,P){const a=e("CustomImage");return p(),h("div",null,[r,n(a,{src:"/growth-record/frame/vue/vue3study01.webp"}),d,s("ul",null,[g,s("li",null,[t("在模板渲染上下文中，只有顶级的 ref 属性才会被解包，但是，另一个需要注意的点是，如果 ref 是文本插值的最终计算值 (即 "),s("code",null,k(),1),t(" 标签)，那么它将被解包")])]),y,n(a,{src:"/growth-record/frame/vue/vue3study02.webp"}),F,n(a,{src:"/growth-record/frame/vue/vue3study03.webp"}),c,n(a,{src:"/growth-record/frame/vue/vue3study04.webp"}),o,n(a,{src:"/growth-record/frame/vue/vue3study05.webp"}),A,n(a,{src:"/growth-record/frame/vue/vue3study06.webp"}),u,n(a,{src:"/growth-record/frame/vue/vue3study07.webp"}),D,C,n(a,{src:"/growth-record/frame/vue/vue3study08.webp"}),v])}const T=l(E,[["render",m]]);export{S as __pageData,T as default};
