<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序图片遮罩层demo]]></title>
    <url>%2F2018%2F07%2F29%2F2018-07-29-wechatMask-demo%2F</url>
    <content type="text"><![CDATA[在工作中经常会用到遮罩层弹窗，所以简单分享一下，之前写过的一个弹出广告图片遮罩层功能demo。 （一）实现效果 （二）实现过程实现过程主要是设置css样式，比较容易理解。1、设置wxml代码布局：设置一个背景布局：用来显示灰色背景；嵌套一个显示展示图片容器，嵌套一个显示闭关按钮的容器。 12345678910 &lt;view class=&quot;b1&quot; hidden=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt; &lt;view class=&quot;b2&quot;&gt; &lt;image src=&apos;../../images/test.jpg&apos;/&gt; &lt;/view&gt; &lt;view class=&quot;t_w&quot;&gt; &lt;cover-view class=&quot;t_image&quot; bindtap=&quot;closeMask&quot;&gt; &lt;cover-image src=&quot;../../images/qcm.png&quot;&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;/view&gt;&lt;/view&gt; 2、wxss样式设置： 12345678910111213141516171819202122232425262728293031/* 设置背景遮罩层样式 */.b1 &#123; position: fixed; width: 100%; height: 100%; top: 0; background: rgba(0, 0, 0, 0.4); display: flex; justify-content: center; align-items: center; flex-direction: column;&#125;/* 设置展示图片大小 */.b2 &#123; width: 50%; height: 50%;&#125;/* 设置展示图片与关闭按钮图片的距离 */.t_w &#123; margin-top: 20rpx;&#125;/* 设置关闭按钮图片显示的大小 */.b2 image &#123; width: 100%; height: 100%;&#125;/* 设置关闭按钮宽高 */.t_image &#123; width: 60rpx; height: 60rpx;&#125; 3、 js两个方法控制显示与关闭操作： 1234567891011 data: &#123; motto: &apos;微信遮罩层显示&apos;, flag: true, &#125;, showMask:function()&#123; this.setData(&#123; flag: false &#125;) &#125;, closeMask: function () &#123; this.setData(&#123; flag: true &#125;) &#125;,&#125;) （三）完整代码代码下载]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>weChatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序登录欢迎页面demo]]></title>
    <url>%2F2018%2F07%2F29%2F2018-07-29-wechatapp-weclomepage%2F</url>
    <content type="text"><![CDATA[之前有用过小程序的欢迎页面，也是GitHub上找到的一个案例。近期有用到，简单的分享一下，可以让有需要的人避免重复造轮子和更好的创新学习。 （一）效果预览直接看效果如何，是否符合您的要求，不符合直接结束浏览，避免浪费您的时间。 （二）代码目录简单实用，直接下载工具打开预览，代码下载 （三）参考文献微信小程序商城，微信小程序微店]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>weChatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的position定位]]></title>
    <url>%2F2018%2F07%2F15%2F2018-07-15-css-position-methods%2F</url>
    <content type="text"><![CDATA[在复习position定位属性，看到一篇介绍很棒的文章，所以转载记录一下。原文章地址点击跳转。 今天给大家分享一下，深度思考中的知识点——position定位有哪几种?各有什么特点? 一、背景介绍position是CSS中非常重要的一个属性，通过position属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。 二、知识剖析position概念：CSS的很多其他属性大多容易理解，比如字体，文本，背景等。有些CSS书籍、博客或网站也会对这些简单的属性进行大张旗鼓的介绍，而偏偏忽略了对一些难缠的属性讲解，有避重就轻的嫌疑。CSS中主要难以理解的属性包括盒型结构，各种垂直居中问题、弹性布局以及定位。正如position is everything.position属性值:position的属性值共有四个常用的：static、relative、absolute、fixed。还有三个不常用的：inherit、initial、sticky。 三、知识详解 Static所有元素在默认的情况下position属性均为static，而我们在布局上经常会用到的相对定位和绝对定位常用的属性top、bottom、left、right或者 z-index声明在position为static的情况下无效。其用法为：在改变了元素的position属性后可以将元素重置为static让其回归到页面默认的文档流中。 Relativerelative定位，又称为相对定位，从字面上来解析，我们就可以看出该属性的主要特性：相对。但是它相对的又是相对于什么地方而言的呢？这个是个重点，也是最让我在学习CSS中迷糊的一个地方，现在让我们来做个测试，我想大家都会明白的：(1) 初始未定位 (2) 我们修改first元素的position属性：相对偏移20px后： 已经很明显了，相对定位相对的是它原本在文档流中的位置而进行的偏移，而我们也知道relative定位也是遵循正常的文档流，它没有脱离文档流，但是它的top/left/right/bottom属性是生效的，可以说它是static到absoult的一个中间过渡属性，最重要的是它还占有文档空间，而且占据的文档空间不会随top / right / left / bottom 等属性的偏移而发生变动，也就是说它后面的元素是依据虚线位置( top / left / right / bottom等属性生效之前)进行的定位，这点一定要理解。 小扩展：那好，我们知道了top / right / left / bottom 属性是不会对relative定位的元素所占据的文档空间产生偏移，那么margin /padding属性会让该文档空间产生偏移吗？ 答案是肯定的，我们一起来做个试验吧：(3) 添加margin属性： 设置margin：20px后：对比一下，答案一目了然，我们先将first元素外边距设为20px，那么second元素就得向下偏移40px，所以margin是占据文档空间！ 同理，大家可以自己动手测下padding的效果！ Absoluteabsolute定位，也称为绝对定位，虽然它的名字号曰“绝对”，但是它的功能却更接近于”相对”一词，为什么这么讲呢？原来，使用absolut定位的元素脱离文档流后，就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以position非static方式定位的，举个例子，a元素使用absolute定位，它会从父类开始找起，寻找以position非static方式定位的祖先类元素(Note!一定要是直系祖先才算.），直到html根标签为止。这里还需要注意的是，relative和static方式在最外层时是以body标签为定位原点的，而absolute方式在无父级是position非static定位时是以html作为原点定位。但是呢，我们都知道html和body元素相差大概有9px左右。我们来看下效果： (4) 添加absolute属性：position: absolute;top :0;left : 0 看了上面的信息后，细心的同学肯定要问了，为什么absolute定位要加 top:0; left:0; 属性，这不是多此一举吗？其实我们加上这两个属性是完全必要的，因为我们如果使用absolute或fixed定位的话，必须指定 left、right、 top、 bottom属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative，会占用文档空间，这点非常重要，很多人使用absolute定位后发现没有脱离文档流就是这个原因，这里要特别注意。 小扩展既然absolute是根据祖先类中的position非static元素进行定位的，那么祖先类中的margin/padding会不会对position产生影响呢？看个例子先： (5) 在absolute定位中添加margin / padding属性： 结果很明朗了，祖先类的margin会让子类的absolute跟着偏移，而padding却不会让子类的absolute发生偏移。总结一下，就是absolute是根据祖先类的border进行的定位。Note : 充分了解Relative和Absolute的区别后，我们可以分析得出这个结论：(absolute)定位对象在可视区域之外会导致滚动条出现。而放置(relative)定位对象在可视区域之外，滚动条不会出现。这点在我们的前端页面制作中需要多加注意~~~ Fixed 在很长的时间里，这个属性值因为兼容性问题，并没有得到非常广泛的应用（IE6未实现该属性值）。fixed和absolute有很多共同点： 1.会改变行内元素的呈现模式，使display之变更为block。 2.会让元素脱离文档流，不占据空间。 3.默认会覆盖到非定位元素上。 所以，fixed与absolute最大的区别在于：absolute的”根元素“是可以被设置的，而fixed则其”根元素“固定为浏览器窗口。即当你滚动网页，其元素与浏览器窗口之间的距离是恒定不变的。 四、拓展知识 z-index属性： z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。 Note：使用static 定位或无position定位的元素z-index属性是无效的。 什么是文档流？将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。只有三种情况会使得元素脱离文档流，分别是：浮动、绝对定位和相对定位。 原作者：Borvay链接：https://www.jianshu.com/p/a116022c6c99來源：简书]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div+css设置水平垂直居中方法]]></title>
    <url>%2F2018%2F07%2F15%2F2018-07-15-div-css-center-vertical%2F</url>
    <content type="text"><![CDATA[之前写前端页面经常会遇到这个问题，所以抽了个时间总结了一下这些常用的方法，通常分为两种情况来设置：已知宽高和未知。简单的分享一下经验。 （一）已知宽高情况的设置 position：absolute;，margin：auto;使用position的绝对定位和margin的居中定位 ，四个方向位置距离设置成一样就行了（通过填充父元素的可用空间 ，子元素设定了宽高，那么多余的空间，被margin：auto平均分配的原理）： 1234567891011121314151617//html代码 &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;div+css设置水平垂直居中显示&lt;/div&gt; &lt;/div&gt; //css样式代码 .box1 &#123; width: 400px; height: 400px; margin: auto; border: 1px solid red; /* 位置值设置相等即可*/ top: 0; left: 0; right: 0; bottom: 0; position: absolute; &#125; 运行结果： 设置 使用position的绝对定位和margin的居中定位，top和left设置与屏幕相距成50%，然后用transform向左（上）平移它自己宽度（高度）的50%即可： 12345678910 .box1 &#123; width: 400px; height: 400px; margin: auto; border: 1px solid red; top: 50%; left: 50%; position: absolute; transform: translate(-50%,-50%); &#125; 运行结果一样。 设置 使用position的绝对定位和margin的居中定位，top和left设置与屏幕相距成50%，使用margin:高的一半px 0 0 宽的一半px; 即可： 12345678910 .box1 &#123; width: 400px; height: 400px; margin: auto; border: 1px solid red; top: 50%; left: 50%; position: absolute; margin: -200px 0 0 -200px; &#125; （二）未知元素宽高这里是使用了两个div的class为box1和box2，方便区别显示，主要设置box2来显示； 通过position的绝对定位和固定定位left和top都设置相对屏幕的50%距离，然后使用transform的translate负偏移来显示： 12345678910111213//html &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;div+css设置水平垂直居中显示&lt;/div&gt; &lt;/div&gt; //css .box2 &#123; border: 5px solid green; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; 运行结果： 通过css设置父元素为display: table，子元素为 display: table-cell，这种方法是让元素包含的内容居中，但是会占据整个父元素，因为子元素没有设置宽高的，如下所示（红线方框是设置宽高的父元素）： 最实用的方法：css3新的布局方法——弹性布局 display: flex。在这个方法中，不管是在已知或未知元素宽高的情况下，都能使元素居中显示（推荐使用）。 1234567891011121314//css.box1 &#123; width: 400px; height: 400px; margin: auto; border: 5px solid red; display: flex; align-items: center;/*垂直居中*/ justify-content: center;/*水平居中*/ &#125; .box2 &#123; border: 5px solid green; &#125; 运行结果：]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 进阶教程之：详解 v-model]]></title>
    <url>%2F2018%2F07%2F15%2F2018-07-15-vue2-v-model%2F</url>
    <content type="text"><![CDATA[本文声明：这是转载简书上的一篇文章，原作者Yi罐可乐，写的这篇文章非常详细却容易理解，对v-model的理解有了更深入的认识，感谢。以下是原文，也可以点击跳转到原文章查看 Vue 官网教程上关于 v-model 的讲解不是十分的详细，写这篇文章的目的就是详细的剖析一下， 并介绍 Vue 2.2 v-model 改进的地方，然后穿插的再说点 Vue 的小知识。 在 Vue 中，有许多方法和 Angular 相似，这主要是因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在许多问题，在 Vue 中已经得到解决。 （一）v-model解析1.v-model用在 input元素上时v-model虽然很像使用了双向数据绑定的 Angular 的 ng-model，但是 Vue 是单项数据流，v-model 只是语法糖而已：↓ 12&lt;input v-model=&quot;sth&quot; /&gt;&lt;input v-bind:value=&quot;sth&quot; v-on:input=&quot;sth = $event.target.value&quot; /&gt; 第一行的代码其实只是第二行的语法糖。然后第二行代码还能简写成这样：&lt;input :value=&quot;sth&quot; @input=&quot;sth = $event.target.value&quot; /&gt; 要理解这行代码，首先你要知道 input 元素本身有个oninput事件，这是 HTML5 新增加的，类似 onchange，每当输入框内容发生变化，就会触发 oninput ，把最新的value传递给 sth。如果你不知道 $event 是从哪来的，那你需要点击它再复习一下文档。 2.我们仔细观察语法糖和原始语法那两行代码，可以得出一个结论： 在给 &lt;input /&gt;元素添加v-model属性时，默认会把 value作为元素的属性，然后把input事件作为实时传递 value的触发事件。 （二）v-model用在组件上时v-model不仅仅能在input上用，在组件上也能使用，下面是一个和 Vue 官网教程类似的例子（在看这个例子时我们要考虑两个问题）： 父组件的 price 的初始值是 100，更改子组件的值能实时更新父组件的 price123456789101112131415161718192021222324252627&lt;div id=&quot;demo&quot;&gt; &lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt; &lt;span&gt;&#123;&#123;price&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.3.0/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;Vue.component(&apos;currency-input&apos;, &#123; template: ` &lt;span&gt; &lt;input ref=&quot;input&quot; :value=&quot;value&quot; &lt;!--为什么这里把 &apos;input&apos; 作为触发事件的事件名？`input` 在哪定义的？--&gt; @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; &lt;/span&gt; `, props: [&apos;value&apos;],// 为什么这里要用 value 属性，value在哪里定义的？貌似没找到啊？&#125;)var demo = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; price: 100, &#125;&#125;)&lt;/script&gt; 如果你知道这两个问题的答案，那么恭喜你真正掌握了 v-model，如果你没明白，那么可以看下这段代码：↓1234&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt;&lt;!--上行代码是下行的语法糖 &lt;currency-input :value=&quot;price&quot; @input=&quot;price = arguments[0]&quot;&gt;&lt;/currency-input&gt;--&gt; 现在你知道 value 和input从哪来的了吧。与上面总结的类似： 给组件添加v-model属性时，默认会把value作为组件的属性，然后把 &#39;input&#39;值作为给组件绑定事件时的事件名 v-model的缺点和解决办法在创建类似复选框或者单选框的常见组件时，v-model就不好用了。 &lt;input type=&quot;checkbox&quot; v-model=&quot;sth&quot; /&gt;v-model 给我们提供好了 value属性和 oninput事件，但是，我们需要的不是value属性，而是 checked 属性，并且当你点击这个单选框的时候不会触发 oninput事件，它只会触发onchange事件。这就尴尬了。 因为v-model只是用到了input元素上，所以这种情况好解决：↓ &lt;input type=&quot;checkbox&quot; :checked=&quot;status&quot; @change=&quot;status = $event.target.checked&quot; /&gt; 当 v-model用到组件上时：↓12345678910&lt;my-checkbox v-model=&quot;foo&quot;&gt;&lt;/my-checkbox&gt;Vue.component(&apos;my-checkbox&apos;, &#123; tempalte: `&lt;input type=&quot;checkbox&quot; @change=&quot;$emit(&apos;input&apos;, $event.target.checked)&quot; :checked=&quot;value&quot; /&gt;` props: [&apos;value&apos;],&#125;) 在 Vue 2.2 版本，你可以在定义组件时通过 model 选项的方式来定制 prop/event：↓123456789101112131415&lt;my-checkbox v-model=&quot;foo&quot;&gt;&lt;/my-checkbox&gt;Vue.component(&apos;my-checkbox&apos;, &#123; tempalte: `&lt;input type=&quot;checkbox&quot; &lt;!--这里就不用 input 了，而是 balabala--&gt; @change=&quot;$emit(&apos;balabala&apos;, $event.target.checked)&quot; :checked=&quot;checked&quot; /&gt;` props: [&apos;checked&apos;], //这里就不用 value 了，而是 checked model: &#123; prop: &apos;checked&apos;, event: &apos;balabala&apos; &#125;,&#125;) 看到这里我相信你肯定理解了 Vue 的 v-model，文中如有错误，欢迎在评论中指出谢谢。 原作者：Yi罐可乐链接：https://www.jianshu.com/p/4147d3ed2e60來源：简书]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0基础知识坑（一）]]></title>
    <url>%2F2018%2F07%2F14%2F2018-07-14-vue2-base-hole1%2F</url>
    <content type="text"><![CDATA[学完vue2.0，在写代码啦官网的方方老师的《Vue 自测题》测试了一下，惨不忍睹，记录一下测试中的容易错误知识点及坑。 （一）安装与介绍 v-bind绑定之问题html部分： 12345 &lt;div id=&quot;app&quot;&gt; &lt;span ____________???____________&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt; js部分： 123456 var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;) 问号处应该填入什么，才能使得 span 的 title 为 message 的值？ 答案是：(1).:title=&quot;message&quot;；(2).v-bind:title=&quot;message&quot;；(3).:title=message；(4).v-bind:title=message；后两种方法很迷，没找到解释，知道的小伙伴欢迎留言，建议答案都自己亲测试一下。 关于不同版本的都是正确的说法：（1）如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版；（2）当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可；（3）运行时版本相比完整版体积要小约 30%； （二）实例与模板 var vm = new Vue(options)其中 options 是一个对象，请问文档中说 options 可以包含哪些 key ？ 答案是：（1） data props propsData computed methods watch（2）el template render renderError（3）beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestroy destroyed errorCaptured（4）directives filters components parent mixins extends provide inject（5）name delimiters functional model inheritAttrs comments data数据问题 html 12345678&lt;div id=&quot;app&quot;&gt; &lt;span class=span-a&gt; &#123;&#123;obj.a&#125;&#125; &lt;/span&gt; &lt;span class=span-b&gt; &#123;&#123;obj.b&#125;&#125; &lt;/span&gt; &lt;/div&gt; js 12345678910var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; obj: &#123; a: &apos;a&apos;, &#125; &#125;,&#125;)app.obj.a = &apos;a2&apos;app.obj.b = &apos;b&apos; 请问最终 span-a 和 span-b 中分别展示什么字符串？ 答案是：span-a 中显示a2，span-b 中显示b，注意不是显示undefined。 文档中建议 Vue 实例的生命周期钩子不要写成箭头函数，给出的理由是什么 答： （1）箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例； （2）经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 （三）计算属性和侦听器 如果 data属性是对象 obj.count，那么要如何写代码才能监听 obj.count 的变化？ 123456789101112var app = new Vue(&#123;el: &apos;#app&apos;,data: &#123; obj:&#123;count: 1&#125;, modified: 0&#125;,watch:&#123; _______???________ this.modified += 1 &#125;&#125;&#125;) 答案是：&#39;obj.count&#39;:function(){可以监听指定的对象属性 如果data中的对象 obj 有 N 个属性，要怎么才能监听所有属性呢？ 123456789101112var app = new Vue(&#123;el: &apos;#app&apos;,data: &#123; modified: 0, obj: &#123;a:1,b:2,c:3&#125;&#125;,created()&#123; this.$watch(&apos;obj&apos;, ()=&gt;&#123; this.modified += 1 &#125;, ___________????_________)&#125;&#125;) 答案是： 12345678watch()&#123; obj:&#123; handler(oldval,newval)&#123; console.log()&#125;,deep:true&#125;&#125; 如果想监听obj对象中的b属性变化时才执行handler函数，可以使用计算属性computed做中间层，如： 12345678910111213141516171819202122var app = new Vue(&#123;el: &apos;#app&apos;,data: &#123; modified: 0, obj: &#123;a:1,b:2,c:3&#125;&#125;,created()&#123; this.$watch(&apos;obj&apos;, ()=&gt;&#123; this.modified += 1 &#125;, computed: &#123; b() &#123; return this.obj.b &#125;&#125;, watch()&#123; b(oldval,newval)&#123; console.log() &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0实战项目——简单的快餐店系统]]></title>
    <url>%2F2018%2F07%2F12%2F2018-07-12-vue2-sellpossystem%2F</url>
    <content type="text"><![CDATA[最近学习vue看到网上很多学习的资料，就找了一个项目系统练习，主要是想学习了的一些知识点，系统的组合运用一遍。网上根据技术胖老师博客的内容自己也实战了一遍，挺实用的，对vue框架有了更深入的了解以及自身能力的提升。 欢迎下载使用或二次开发。 （一）项目分析这个项目主要是实现在线的用户点餐以及对点餐列表商品的增删改查等功能；然后使用mockplus工具画出草图，主要是方便开发。 （二）运用到的技术1.使用vue-cli2.x搭建的开发环境； 2.使用vue-router做路由转换； 3.使用element-ui做界面美化； 4.使用axios做跨域请求接口数据； 5.使用icofont在线图标管理； 6.使用webpack打包管理； 7.使用vue2.0语法和es6语法； （三）系统成果 （四）系统使用1.前提是要有node.js、npm、vue-cli环境（最好有Git，会方便很多）； 2.下载项目（git clone最好）； 3.打开终端切换到该项目名称下，执行以下命令行：12345# install dependencies 安装开发环境的依赖，因为不是直接打包上传的项目npm install# serve with hot reload at localhost:8080 运行项目基本没问题npm run dev 参考文献技术胖老师的 Vue实战视频-快餐店收银系统]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js2.0生命周期的理解与应用]]></title>
    <url>%2F2018%2F07%2F08%2F2018-07-08-vue2-lifestyle%2F</url>
    <content type="text"><![CDATA[在学习vue2.x入门后，开始慢慢熟悉vue的模式和开发脚手架项目实践过程中，需要对生命周期钩子函数一定的理解，多少会用到这些钩子函数，根据自己的理解写了一下，欢迎指正或学习交流。 （一）vue2.x生命周期图 （二）生命周期钩子函数说明 生命周期钩子函数 说明 beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)属性初始化和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当mounted被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 （三）代码演示 通过嵌套组件的页面加载查看显示顺序：代码如下(可直接复制使用)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;vue生命周期的理解应用&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;p&gt;以下是调用组件信息&lt;/p&gt; &lt;div class=&quot;test&quot;&gt; &lt;keep-alive&gt;&lt;/keep-alive&gt; &lt;test-component v-bind:msg=&quot;msg&quot; v-on:msgchange=&quot;updateMsg($event)&quot;&gt;&lt;/test-component&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var child = &#123; props: [&apos;msg&apos;], template: &apos;&lt;button v-on:click=&quot;changeChuanzhi&quot;&gt;点击向父组件事件传值--&#123;&#123;msg&#125;&#125;&lt;/button&gt;&apos;, methods: &#123; changeChuanzhi: function () &#123; this.$emit(&quot;msgchange&quot;, &quot;子组件向父组件传值&quot;); //注意两个参数：第一个参数是事件名，第二个参数是传递的内容 &#125; &#125;, deactivated: function () &#123; console.log(&apos;component deactivated!&apos;); &#125;, activated: function () &#123; console.log(&apos;component activated&apos;); &#125; &#125;; new Vue(&#123; el: &apos;#vue-app&apos;, data: &#123; msg: &apos;父亲给儿子的信息&apos; &#125;, methods: &#123; updateMsg: function (msg) &#123; this.msg = msg; &#125; &#125;, components: &#123; &apos;test-component&apos;: child &#125;, //生明周期示例 beforeCreate: function () &#123; alert(&quot;组件实例化之前执行的函数：beforeCreate()&quot;); &#125;, created: function () &#123; alert(&quot;组件实例化完毕，但页面还未显示出来:created()&quot;); &#125;, beforeMount: function () &#123; alert(&quot;组件挂载前，页面仍未展示，但虚拟DOM已经配置:beforeMount()&quot;); &#125;, mounted: function () &#123; alert(&quot;组件挂载后，此方法执行后，页面显示:mounted()&quot;); &#125;, beforeUpdate: function () &#123; alert(&quot;组件更新前，页面仍未更新，但虚拟DOM已经配置:beforeUpdate()&quot;); &#125;, updated: function () &#123; alert(&quot;组件更新后，此方法执行后，页面显示:updated()&quot;); &#125;, beforeDestroy: function () &#123; alert(&quot;组件销毁前:beforeDestroy()&quot;); &#125;, destroyed: function () &#123; alert(&quot;组件销毁:destroyed()&quot;); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 运行结果： 通过控制台查看页面加载显示顺序日志：代码如下（可直接复制使用）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;vue生命周期的理解应用&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;p&gt;以下是调用组件信息&lt;/p&gt; &lt;div class=&quot;test&quot;&gt; &lt;p&gt;默认显示的数据：&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;test-component v-bind:msg=&quot;msg&quot; v-on:msgchange=&quot;updateMsg($event)&quot;&gt;&lt;/test-component&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var child = &#123; props: [&apos;msg&apos;], data: function () &#123; return &#123; childtofather: &apos;子组件向父组件传值&apos; &#125; &#125;, template: &apos;&lt;button v-on:click=&quot;changeChuanzhi&quot;&gt;点击向父组件事件传值--&#123;&#123;msg&#125;&#125;&lt;/button&gt;&apos;, methods: &#123; changeChuanzhi: function () &#123; this.$emit(&quot;msgchange&quot;, this.childtofather); //注意两个参数：第一个参数是事件名，第二个参数是传递的内容 &#125; &#125;, &#125;; var app =new Vue(&#123; el: &apos;#vue-app&apos;, data: &#123; msg: &apos;父亲给儿子的信息&apos; &#125;, methods: &#123; updateMsg: function (msg) &#123; this.msg = msg; &#125; &#125;, components: &#123; &apos;test-component&apos;: child &#125;, //生明周期示例 beforeCreate: function () &#123; // alert(&quot;组件实例化之前执行的函数：beforeCreate()&quot;); console.group(&apos;beforeCreate 创建前状态===============》&apos;); var state1 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(state1); &#125;, created: function () &#123; // alert(&quot;组件实例化完毕，但页面还未显示出来:created()&quot;); console.group(&apos;created 创建完毕状态===============》&apos;); var state2 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(state2); &#125;, beforeMount: function () &#123; // alert(&quot;组件挂载前，页面仍未展示，但虚拟DOM已经配置:beforeMount()&quot;); console.group(&apos;beforeMount 挂载前状态===============》&apos;); var state3 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state3); &#125;, mounted: function () &#123; // alert(&quot;组件挂载后，此方法执行后，页面显示:mounted()&quot;); console.group(&apos;mounted 挂载结束状态===============》&apos;); var state4 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state4); &#125;, beforeUpdate: function () &#123; // alert(&quot;组件更新前，页面仍未更新，但虚拟DOM已经配置:beforeUpdate()&quot;); console.group(&apos;beforeUpdate 更新前状态===============》&apos;); var state5 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state5); debugger &#125;, updated: function () &#123; // alert(&quot;组件更新后，此方法执行后，页面显示:updated()&quot;); console.group(&apos;updated 更新完成状态===============》&apos;); var state6 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state6); &#125;, beforeDestroy: function () &#123; // alert(&quot;组件销毁前:beforeDestroy()&quot;); console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); var state7 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state7); &#125;, destroyed: function () &#123; // alert(&quot;组件销毁:destroyed()&quot;); console.group(&apos;destroyed 销毁完成状态===============》&apos;); var state8 = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;msg&apos;: this.msg &#125; console.log(this.$el); console.log(state8); &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 简单说明一下结构： （1）创建了一个Vue根实例命名为vue-app，将其挂载到页面id为vue-app的dom元素上。 （2）局部注册的一个组件child并在根实例中将其注册使其可以在根实例的作用域中使用。 （3）将子组件用&lt;keep-alive&gt; 包裹，为接下来的测试作准备。 （4）打开开发者工具的控制台查看结果： 结果分析1.beforeCreate执行时：data和el均未初始化，值为：undefined；2.created执行时：Vue 实例观察的数据对象data已经配置好，已经可以得到vue-app.msg的值，但Vue 实例使用的根 DOM 元素el还未初始化；3.beforeMount执行时：data和el均已经初始化，但从等页面展示数据可以看出此时el并没有渲染进数据，el的值为“虚拟”DOM的元素节点； 4.mounted执行时：此时el已经渲染完成并挂载到实例上，页面基本显示完成； 5.beforeUpdate执行时：会更新当前组件数据，但未在页面渲染出来； 6.updated执行时：会更新当前组件数据，并在页面渲染出来； 7.beforeDestroy和destroyed执行时：Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。注意：这里的销毁并不指代’抹去’，而是表示’解绑’。 验证一下，控制台输入：app.msg=&#39;super456&#39; 页面并没有显示出来，结果显示： （四）一些钩子函数应用1.beforeCreate钩子中可以进行loading之类的动画加载；2.在created钩子中可以对data数据进行操作，这个时候可以进行ajax请求将返回的数据赋给data，还可以进行网络接口的请求操作；3.在mounted钩子对挂载的dom进行操作，也可以进行后台获取数据操作； （五）文献参考特别感谢：作者：hxgzj 的关于Vue.js2.0生命周期的研究与理解 这篇文章分析的很详细，看完后参考写了一个案例出来的。内容中也引用了很多。]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0基础知识点（一）]]></title>
    <url>%2F2018%2F07%2F07%2F2018-07-07-vue2-base1%2F</url>
    <content type="text"><![CDATA[本文针对自己学习官方文档时，总结一些易容易混淆的知识点做一下记录。欢迎指正或学习交流。 （一）常用基础知识点 v-on:click=&#39;&#39;、@click=&#39;&#39;、:click=&#39;&#39; 三种写法；注意函数调用：直接使用双花括号调用函数是要使用函数名+括号，其他直接使用函数名即可，或使用函数名+括号（click事件中）注意传参的函数必须带括号，可以不带参数，不然会报错对象空值； v-if=&#39;&#39; 条件渲染与v-show=&#39;&#39; 的区别：v-if 条件：不存在不会占位空间不会被渲染挂载；v-show为真时，去掉display：none，为假时显示display：none。默认会占用空间，会被渲染挂载。 v-for=&#39;&#39; 可以通过两组方式遍历数组（也可以遍历对象）：一种是通过数组下标；另一种是循环遍历；v-for=&#39;user in users&#39; 或 v-for=&#39;(user,index) in users&#39; 第二个参数是数组索引值； 12345678910111213141516171819 &lt;p&gt;v-for还可以渲染div&lt;/p&gt;&lt;div v-for=&apos;(user,index) in users&apos;&gt; &lt;h3&gt;&#123;&#123;index+1&#125;&#125;&lt;/h3&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;---&#123;&#123;user.age&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;p&gt;v-for使用template标签，这个标签不像div一样会被渲染出来，只渲染template里面的标签&lt;/p&gt;&lt;template v-for=&apos;(user,index) in users&apos;&gt; &lt;h3&gt;&#123;&#123;index+1&#125;&#125;&lt;/h3&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;---&#123;&#123;user.age&#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;p&gt;遍历数组里面的对象，遍历两次&lt;/p&gt;&lt;template v-for=&apos;(user,index) in users&apos;&gt; &lt;div v-for=&quot;(item,key) in user&quot; &gt; &lt;h5&gt;&#123;&#123;item&#125;&#125;---&#123;&#123;key&#125;&#125;&lt;/h5&gt; &lt;/div&gt;&lt;/template&gt; 数据双向绑定的两种方法： 1234567891011121314151617 &lt;p&gt;双向数据绑定ref/$refs示例：input/select/textarea&lt;/p&gt;&lt;label for=&quot;&quot;&gt;姓名&lt;/label&gt;&lt;!-- ref属性标记值，可获取 --&gt;&lt;input type=&quot;text&quot; v-on:keyup=&quot;logName&quot; ref=&apos;refName&apos;&gt;&lt;span&gt;您输入的名字为：&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;&lt;input type=&quot;text&quot; v-on:keyup=&apos;logAge&apos; id=&quot;age&quot; ref=&quot;refAge&quot;&gt;&lt;span&gt;您输入的年龄为：&#123;&#123;age&#125;&#125;&lt;/span&gt;&lt;p&gt;双向数据绑定v-model示例：input/select/textarea&lt;/p&gt;&lt;label for=&quot;&quot;&gt;姓名&lt;/label&gt;&lt;!-- ref属性标记值，可获取 --&gt;&lt;input type=&quot;text&quot; v-model=&apos;name&apos;&gt;&lt;span&gt;您输入的名字为：&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;&lt;span&gt;您输入的年龄为：&#123;&#123;age&#125;&#125;&lt;/span&gt; js部分： 12345678910111213141516171819 new Vue(&#123; el:&apos;#vue-app&apos;, data:&#123; name:&apos;&apos;, age:&apos;&apos; &#125;, methods:&#123; logName:function()&#123; // console.log(&quot;您正在输入名字~&quot;); // $refs获取标记的值，后面接命名值+value // console.log(this.$refs.refName.value); this.name=this.$refs.refName.value; &#125;, logAge:function()&#123; // console.log(&quot;您正在输入年龄~&quot;); this.age=this.$refs.refAge.value; &#125; &#125;&#125;) computed 和 methods 方法：只要methods方法之一被调用，其他所有方法都会被渲染执行，很耗费性能；计算属性，只会调用相应的方法体，是应用于搜索，调用比较多的方法体。]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-cli2.x入门简单demo游戏]]></title>
    <url>%2F2018%2F07%2F05%2F2018-07-05-vue2-demo-game%2F</url>
    <content type="text"><![CDATA[vue-cli2.x-demo第一次使用vue-cli2.x搭建一个小demo游戏。代码文件有很多注释信息，通俗易懂的使用这个脚手架搭建一个入门小项目哈。 介绍使用 使用默认创建的脚手架； 修改App.vue、HelloWorld.vue文件，assets文件夹添加了两张图片； 然后编译运行； 运行截图 参考文献 Web前端网站教程-米斯特吴 源码在我的GitHub上：点击跳转]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础父子组件输入动态传值]]></title>
    <url>%2F2018%2F06%2F26%2F2018-06-26-vue2-component%2F</url>
    <content type="text"><![CDATA[在学习vue2.x的时候，遇到了一个问题，就是父子组件如何传递动态输入的值，文档介绍都是传递固定值的，比如我想传递一个刚输入的值呢，子组件如何显示？一下就是简单的代码： 注：本人使用的是官方的脚手架学习的，可以通过父级组件向子级组件传递动态输入的值。然后本人重写了一个测试页面，直接复制代码就可以运行的（看懂以下代码，父子组件传递原理也是一样的，此处以对象为例）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;父组件向子组件动态传值示例&lt;/title&gt; &lt;!-- 导入官方cdn的vue文件--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;添加一个列表项： &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot; v-on:keyup.enter=&apos;addNew()&apos; placeholder=&quot;按回车键提交&quot;&gt; &lt;/p&gt; &lt;p&gt;显示输入框传递给子组件的添加内容（对象）：&lt;/p&gt; &lt;!-- 注意这个传递的参数值必须前面有：v-bind:组件获取的变量名=&apos;需要传递的变量名&apos; 或 :组件获取的变量名=&apos;需要传递的变量名&apos; ,否则传递的永远是字符串的值--&gt; &lt;!-- 这种方式传递的是字符串 --&gt; &lt;!-- &lt;component-a msg1childtofather=&apos;msgchildtofather&apos;&gt;&lt;/component-a&gt; --&gt; &lt;!-- 以下两种方式都是传递对象 --&gt; &lt;component-a :msg1childtofather=&apos;msgchildtofather&apos;&gt;&lt;/component-a&gt; &lt;!-- &lt;component-a v-bind:msg1childtofather=&apos;msgchildtofather&apos;&gt;&lt;/component-a&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component(&apos;component-a&apos;, &#123; props: [&apos;msg1childtofather&apos;], template: &apos;&lt;h2 v-text=\&apos;msg1childtofather\&apos;&gt;&lt;/h2&gt;&apos;, methods: &#123; output: function () &#123; alert(&apos;You click button! and submit value:&apos; + this.msg1childtofather); &#125; &#125; &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123; items: [], newItem: &quot;&quot;, msgchildtofather: &quot;&quot; &#125;, methods: &#123; addNew: function () &#123; // 使用v-model和ul li input向数组items添加一个动态项内容，注意添加数组格式 this.items.push(this.newItem); // 测试传递动态添加对象值 var childfather = &#123; label: this.newItem, label2: &apos;默认值&apos; &#125;; this.msgchildtofather = childfather; this.newItem = &quot;&quot;; &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 测试结果如下：]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue2基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序筛选框]]></title>
    <url>%2F2018%2F05%2F09%2F2018-05-09-wxapp-filterbar%2F</url>
    <content type="text"><![CDATA[本来是一个GitHub上wux-weapp组件的筛选框，但是整个项目过于系统化，想提取某个组件都是有点难度的，首先要看得懂某个组件的整个生命逻辑，所以自己也是摸索过来的，便简单的提取了wux-weapp组件的FilterBar筛选框的部分功能，满足个人需求及分享一下。 （一）原组件信息原组件是GitHub上的wux - 微信小程序自定义组件可以实现对话框、指示器、五星评分等22种功能。点击这里跳转查看原组件 （二）原组件筛选框 （三）提取的组件主要提取了筛选框页面中通过点击某个字或按钮右侧弹出的方式，方便个人将该组件放在任意需要的位置。 下载代码 简单的分享，各取所需吧。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>weChatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天真的好心塞]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-heart-hurt%2F</url>
    <content type="text"><![CDATA[好久没有这么难受过了，可能经历过不如意的事情积累都一定程度是会爆发出来的吧！ 我想要的从上大学以来，大一大二的生活，虽然不是那么逍遥、得意。但至少，没有那么多的烦恼，没有那么多的忧虑，没有那么多的害怕。那时候的自己，真的是，拿得起，放得下，心态很稳，就算遇到不开心的事，忍忍就过了，心中的热情很高涨，主要是对生活的还是很乐观的。 很难得到结果，自从上了大三，真的是经历的人生中的过山车一样，最高点没站稳，就已经下坡很快了。失望的、绝望的事一推一堆。真的不能像个平常人一样笑得很自然了，就算是笑，都感觉带着心酸了。真的是好累、好累。 造物弄人大三下学期，开学到现在也是，不如意的事，也很多。关键是总感觉自己运气差的要死，心态都要崩溃了。好烦、好烦。以前总以为自己心态放好一点，眼不见心不烦，与其抱怨，不如想想怎么变得更好。这些都是安慰自己的谎言，时间都抹去不了，太刻苦铭心了。总以为努力就可以做的更好，结果还是得不到回报，只会让自己更受伤害，甚至留下眼泪，让你看清现实。 生活好累 其实，我一点都不是一个悲观主义者，自己喜欢开同学玩笑，看内涵段子，努力有梦想的人。我也不是因为一些经历不如意的事就应该自暴自弃，而不是去反思自己以后做的更好的人。该笑的笑，该哭的哭，只要不是生死抉择的问题。没有什么大不了，大不了重头再来是吧。 高进的《有太多人》的中有几句歌词：也许你很在乎，别人眼中的自己，就算拼了命，只为了得到一次肯定，太难过的时候，就哭不出声音，擦干泪无所谓。 我有酒也有故事，就是等不到一个愿意听我讲的人。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些容易忽视的JS基础知识]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23-return-js-base%2F</url>
    <content type="text"><![CDATA[（一）、函数 使用未声明的变量时，它将自动被视为全局变量，即便你在函数中首次使用它亦如此。 12345678 function playTurn(player,location)&#123;// 使用变量points前，我们忘了关键字var声明它，因此它被自动视为全局变量 points=0; if(location==1)&#123; points=points+100; &#125; return points; &#125; 如果局部变量与全局变量同名，它将“遮住”全局变量。 12345678var beanCounter=10;//全局变量function getNumberOfItems(ordertype)&#123; var beanCounter=0;//局部变量 if(ordertype=="order")&#123; // &#125; return beanCounter;&#125; 因此每次调用函数使用的是局部变量beanCounter时，都会遮住全局变量，但是全局变量和局部变量不会相互影响：如果你修改其中的一个，对另一个不会有任何影响，它们是彼此独立的变量。 如果形参与全局变量同名，它会遮住全局变量。 函数声明和函数表达式区别： 使用函数声明时，函数将在执行代码前创建；而使用函数表达式时，函数将在运行阶段执行代码时创建。（简单的说浏览器执行代码分两遍时，第一遍分析所有的函数声明，并定义函数声明创建的函数，第二遍浏览器从上到下顺序执行代码，并定义函数表达式创建的函数。） 使用函数声明时，将创建一个与函数同名的变量，并让它指向函数；而使用函数表达式时，通常不给函数指定名称，因此你要么在代码中将函数赋给一个变量，要么以其他方式使用函数表达式。 函数用法：可以将函数赋给变量；可以将函数传递给函数；可以从函数返回函数。 12345678910111213141516171819202122232425262728293031323334353637383940 //可以将函数传递给函数//定义一个对象变量 var passengers = [&#123; name: "dudu", paid: true, ticket: "firstclass" &#125;, &#123; name: "jane", paid: true, ticket: "coach" &#125;, &#123; name: "Sue", paid: false, ticket: "firstclass" &#125;, &#123; name: "Fujia", paid: true, ticket: "caoach" &#125;]; //创建一个传递函数，参数一个是对象一个是函数 function processPassengers(passengers, testFunction) &#123; for (var i = 0; i &lt; passengers.length; i++) &#123; if (testFunction(passengers[i].name)) &#123; return false; &#125; &#125; return true; &#125; //创建需要作为参数传递的函数 function checkNoFlyList(passenger) &#123; return (passenger.name === "dudu"); &#125; // 向函数传递函数 var allCanFly = processPassengers(passengers, checkNoFlyList);//第一个参数是对象，第二个参数是函数 if (allCanFly) &#123; alert("这架飞机不能起飞，因为有乘客在禁飞名单里面"); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//可以从函数返回函数//定义一个对象变量 var passengers = [&#123; name: "dudu", paid: true, ticket: "firstclass" &#125;, &#123; name: "jane", paid: true, ticket: "coach" &#125;, &#123; name: "Sue", paid: false, ticket: "firstclass" &#125;, &#123; name: "Fujia", paid: true, ticket: "caoach" &#125;]; function createDrinkOrder(passenger) &#123; var orderFunction;//创建一个变量用于存储要返回的函数 if (passenger.ticket === "firstclass") &#123; orderFunction = function() &#123;//定义返回的函数代码 alert("Would you like a cocktail or wine?"); &#125;; &#125; else &#123; orderFunction = function() &#123;//定义返回的函数代码 alert("Your choice is cola or water."); &#125;; &#125; return orderFunction;//返回创建的函数 &#125; function serveCustomer(passenger) &#123; var getDrinkOrderFunction = createDrinkOrder(passenger);//注意这里是将返回的函数赋给变量引用 getDrinkOrderFunction();//引用变量指向返回的函数 &#125; function servePassengers(passengers) &#123; for (var i = 0; i &lt; passengers.length; i++) &#123; serveCustomer(passengers[i]); &#125; &#125; servePassengers(passengers); （二）、对象 可以随时增删属性： fido.dogYears=35;就新增对象fido的一个属性dogYears，并赋值为35 , delete fido.dogYears;删除了一个对象fido的属性dogYears，如果成功删除了属性，delete表达式将返回true，仅当属性无法删除时，delete才返回false。如果对象属于浏览器而受到保护，即便你要删除的属性在对象中不存在，delete也将返回true。 对象变量存储的不是对象本身，而是指向对象的引用，因此对象变量也被称为引用变量。 向函数传递对象时，函数获得的是指向该对象的引用的副本，而不是对象本身的副本。因此，如果在函数中修改属性的值，修改的将是原始对象的值。 调用对象的方法时，关键字this指向其方法被调用的对象。要在对象的方法中访问对象的属性，必须使用句点表示法，但使用关键字this而不是对象名。 1234567891011121314151617var fiat=&#123; make:"Fiat", started:false, start:function()&#123; this.started=true; &#125;, stop:function()&#123; this.started=false; &#125;, drive:function()&#123; if(this.started)&#123; alert("Zoom Zoom"); &#125;else&#123; alert("You need to start the engine first."); &#125; &#125;&#125;; 需要创建大量类似的对象时，适合使用构造函数。注意new和this的使用。 （三）、类型 undefined类型: 没有return语句的函数返回的值。 未赋值的变量的值。 稀疏数组中不存在的数组元素的值。 已删除的属性的值。 创建对象时没有赋给属性的值。 null表示对象不存在，跟undefined的区别是：在应该提供一个对象，但无法创建或找到时，将提供null；在变量未初始化、对象没有指定属性或数组没有指定元素时，将返回undefined。 NaN表示无法用数字表示的数值结果，但它的类型仍是数字，注意：NaN!=NaN。判断一个数是不是NaN，使用isNaN()。 12var test=0/0;console.log(typeof test);//number 在JavaScript中总共有5个假值：undefined，null，0，&quot;&quot;和false；其他值都是真值。 （四）、闭包 闭包：名词，指的是函数和引用环境。包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起，被称为闭包。 123456789101112 function makeCounter() &#123; var count = 0; function Counter() &#123; count = count + 1; return count; &#125; return Counter;//这是一个闭包&#125;var doCount = makeCounter();//调用函数试，获得的是一个闭包：一个函数及其环境console.log(doCount());console.log(doCount()); （五）、原型 原型：对象可以从其他对象那里继承属性和行为。更具体地说，js使用原型式继承，其中其行为被继承的对象称为原型（对象继承另一个对象后，就可以访问其多有的方法和属性）。 给构造函数的原型添加属性后，使用这个构造函数创建的实例都将继承这些属性。即便是以前创建的实例也不例外。 使用自定义的原型对象时，务必将原型的属性constructor设置为相应的构造函数，以保持一致。 要调用函数并指定函数体中this指向的对象，可调用其方法call()； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//定义一个构造函数 function Dog(name, breed, weight) &#123; this.name = name; this.breed = breed; this.weight = weight; &#125; //给构造函数原型添加属性 Dog.prototype.species = "Canine"; //给构造函数原型添加方法 Dog.prototype.bark = function() &#123; if (this.weight &gt; 25) &#123; console.log(this.name + "Says Woof"); &#125; else &#123; console.log(this.name + "says Yip"); &#125; &#125;; Dog.prototype.run = function() &#123; console.log("Run"); &#125;; Dog.prototype.wag = function() &#123; console.log("wag"); &#125;; //定义一个继承Dog构造函数的新的构造函数 function ShowDog(name, breed, weight, handler) &#123; // this.name = name; // this.breed = breed; // this.weight = weight; // Dog(name, breed, weight); 后面调用Dog原型属性会返回undefined Dog.call(this, name, breed, weight);//注意这里要使用this this.handler = handler; &#125; // //ShowDog.prototype = new Dog(); ShowDog.prototype.constructor = ShowDog;//设置构造函数ShowDog的原型指向自己本身 ShowDog.prototype.league = "Webville"; ShowDog.prototype.stack = function() &#123; console.log("Stack"); &#125;; ShowDog.prototype.bait = function() &#123; console.log("Bait"); &#125;; ShowDog.prototype.gait = function(kind) &#123; console.log(kind + "ing"); &#125; ShowDog.prototype.groom = function() &#123; console.log("Groom"); &#125; var scotty = new ShowDog("Scotty", "Scottish Terrish", 15, "Cookie"); console.log(scotty.name); //undefined，原因是showDog中使用的是： Dog(name, breed, weight); scotty.stack(); scotty.bark(); console.log(scotty.league); console.log(scotty.species); console.log("scotty constructor is:" + scotty.constructor); //showDog 参考文献 《Head First JavaScript 程序设计》]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何简单的使用VScode编程工具]]></title>
    <url>%2F2018%2F02%2F24%2F2018-02-24-simple-use-vs-code%2F</url>
    <content type="text"><![CDATA[由于经常使用，之前使用一些功能老是过段时间就忘记，只记住一些基本的操作。俗话说：工欲善其事，必先利其器。所以打算整理一下，以便忘记的时候可以温习一下，不至于浪费编码时间。 Visual Studio Code 是一个运行在桌面上，多平台的轻量级且功能强大的源代码编辑器。内置有JavaScript的，TypeScript和Node.js的支持，其他语言如C ++，C＃，Python和PHP等的可扩展，是一个非常丰富的生态系统。主打 web 开发，也是本人在学习前端过程中主要的使用的编程工具。 主命令框 F1或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：按一下Backspace会进入到 Ctrl+P模式 在Ctrl+P下输入&gt;可以进入Ctrl+Shift+P模式 在 Ctrl+P窗口下还可以: 直接输入文件名，跳转到文件 ?列出当前可执行的动作 !显示 Errors或 Warnings，也可以Ctrl+Shift+M :跳转到行数，也可以 Ctrl+G直接进入 @跳转到symbol（搜索变量或者函数），也可以 Ctrl+Shift+O直接进入 @根据分类跳转symbol，查找属性或函数，也可以 Ctrl+Shift+O后输入:进入 #根据名字查找 symbol，也可以 Ctrl+T 常用快捷键 说明 快捷键 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 切出一个新的编辑器（最多 3 个） Ctrl+\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 编辑器换位置 Ctrl+k然后按 Left或 Right 代码编辑格式调整注意： 对python文件进行代码格式化操作时，会提示安装autopep8 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 代码行缩进: Ctrl+[ 、 Ctrl+] 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 光标相关 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去:Alt+F12 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 跳转到光标上一次(下一次)位置（误操作的回退方案，非常有用）ctrl + Left / Ctrl + Right 注意： 下面两个功能和alt+↑/↓配合，很方便的移动代码块： 选择从光标到行尾：Shift+End 选择从行首到光标处：Shift+Home 注意： 这两个功能很爽，可以同时编辑一些变量名： 多行编辑(列编辑)：Ctrl+Alt+Down/Up或者Alt+Shift+鼠标左键，可以批量选中文本并编辑 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多光标选取Alt + 鼠标单击 逐步选中其它相同的symbol Ctrl + D(已更改快捷方式为：Ctrl+Shift+K) 全选相同symbolCtrl + F12 重构（重命名）Symbol F2 查找所有引用了选中symbol的代码 Shift + F12 跳转到symbol的定义处 F12 瞥见下symbol的定义出（在该symbol下方展开面板，显示定义处代码，非常有用）Alt + F12 重构代码注意： 查看函数引用和批量休修改函数名，好用： 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找:Ctrl+F 查找替换:Ctrl+H 整个文件夹中查找:Ctrl+Shift+F 显示相关 全屏：F11 区域整块放大/缩小：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器:Ctrl+Shift+E 显示搜索:Ctrl+Shift+F 显示 Git:Ctrl+Shift+G 显示 Debug:Ctrl+Shift+D 显示 Output:Ctrl+Shift+U 其他文件自动保存设置：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto 修改默认快捷键打开默认键盘快捷方式设置：File（文件） -&gt; Preferences（首选项） -&gt; Keyboard Shortcuts（键盘快捷方式），或者：Alt+F -&gt;p-&gt; k-&gt; 回车。 修改keybindings.json：(这个是当时自己添加的) 123456789101112131415161718// ctrl+d 删除一行 &#123; &quot;key&quot;: &quot;ctrl+d&quot;, &quot;command&quot;: &quot;editor.action.deleteLines&quot;, &quot;when&quot;: &quot;editorTextFocus&quot; &#125;, // 与删除一行的快捷键互换 &#123; &quot;key&quot;: &quot;ctrl+shift+k&quot;, &quot;command&quot;: &quot;editor.action.addSelectionToNextFindMatch&quot;, &quot;when&quot;: &quot;editorFocus&quot; &#125;, // ctrl+shift+/多行注释 &#123; &quot;key&quot;:&quot;ctrl+shift+/&quot;, &quot;command&quot;: &quot;editor.action.blockComment&quot;, &quot;when&quot;: &quot;editorTextFocus&quot; &#125;, 推荐前端开发会用到的插件 auto close tag 自动关闭HTML标签 Auto Rename Tag：自动修改标签 AutoFileNmae:auto complete file name，自动补全文件的名字 Beautify:显示js/json/css美化，按F1 Bracket Pair Colorizer 标记显示不同颜色的关联括号 Color Info 显示颜色信息 CSS Formatter css格式化工具 Debugger for Chrome 谷歌调试工具（需要配置launch.json） Document This 添加备注信息（only supports JavaScript and TypeScript）Ctrl+Alt+D and again Ctrl+Alt+D filesize 文件大小提示 GitLens 提示文件修改信息，具体到代码行 Guides:显示代码对其辅助线 HTML CSS Support css文件支持HTML标签提示 HTML Preview 预览编译HTML文件 HTML SCSS Support scss文件支持HTML标签提示 HTML Snippets 支持HTML标签提示 HTMLHint intellisense for css class names in html 支持HTML文件中类名提示 JavaScript (ES6) snippets jQuery Code Snippets JS, CSS, HTML Formatting Live HTML Previewer markdownlint Npm Intellisense Path Intellisense: 路径匹配 Path Autocomplete Vetur：VUE扩展 PostCSS Sorting stylelint stylefmt ESLint javascript standard format Babel ES6/ES7 Add jsdoc comments vue weex Reactjs code snippets React Native Tools Instant Markdown Markdown Shortcuts TextTransform Color Highlight:写csss时，颜色值会增加对应的颜色背景显示 open in browser: alt+b选择浏览器预览文件 Rainbow Brackets：有颜色的显示括号匹配 Settings Sync: 同步配置（需要配置GitHub的本地token key） 官网推荐插件点击跳转 推荐主题点击跳转 注： 切换主题的快捷键：f1 或ctrl+shift+p输入theme 回车,上下切换：ctrl+k,ctrl+t。 One Dark Pro Atom One Dark FlatUI Material Icon Theme: 图标主题 vscode-icons VSCode Great Icons Dracula Official：主题，推荐 参考文献 打造性感好用的VS Code编辑器 Visual Studio Code 简明使用教程 VScode中文文档 Visual Studio Code 不完全使用指南]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客名称更改]]></title>
    <url>%2F2018%2F02%2F13%2F2018-02-23-new-myblog-name%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在家无聊，努力的动力不大，但是不能总闲着，没事做就看书。本来之前想改博客名称的，一时想不到好的，现在想到了，就改了一个字而已，哈哈哈，有点无聊吧，不过，改完之后更能表现我内心的世界，最真实的想法，这才是最好的。2018，狗年一切都旺起来呦！]]></content>
      <categories>
        <category>建站记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018，我还没准备好开始呢]]></title>
    <url>%2F2018%2F01%2F23%2F2018-01-23-new-start%2F</url>
    <content type="text"><![CDATA[“这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直想写一份2017年的总结报告，就是想回首自己在这一年的得与失，更多的是想认清自己，然后想想未来的路要怎么走。可能这大三上学期，过的很复杂，更多的是不如意，但都过去的事了，没什么好说的，还是挺过来了，但这些都不算什么。总的来说就是一句话：越想得到的东西，越是得不到或者不如意，有些东西，注定是得不到的时候才是最好的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2018，你还是来了，不知不觉，而且已经过了半个多月了。然而我一切都还没打算好，我也不知道以后要怎么做的更好了，很迷茫，也会很累。我知道自己改变不了什么，就只是不想浑浑噩噩过日子而已。好吧，我会答应自己，过好每一天，哪怕是最简单的一天，我知道我不要变的那么孤独，要相信，这个世界上的真的有很多人在过着我想要的生活。2017，不再留念，2018，昂首前行。 相信自己，好好活着。:dog: :punch: :smiley:]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学生课程评教管理系统]]></title>
    <url>%2F2017%2F12%2F01%2F2017-12-01-javaweb-ces%2F</url>
    <content type="text"><![CDATA[学生课程评教管理系统（一）系统介绍本系统是针对我们学院课程接近期末会用纸质版评教卡对老师本学期的课程评分的不便及效率问题而做的在线学生课程评教管理系统。 本系统主要包括系统管理员、教师、学生三种类型的用户，以下是主要功能，其他以实际开发为准。 系统管理员：完成系统管理与维护，例如，维护学生、教师及管理人员的维护。管理课程信息、课程评比、课程评教卡内容等。 教师：可以查询所教班级的评教情况、查询教师好评榜的评比结果、查询留言。 学生：可以查询自己的基本信息，可以对自己所选课程的老师进行评教、留言。 （二）系统技术介绍本系统是学习JSP课程而做的练习，欢迎二次开发。 使用MVC模式开发； 界面使用HTML5、CSS3、boostrap封装； 使用jQuery库DOM处理； 使用一些组件特效（比如选项卡画面、登录背景方块滚动等）； 使用SQL Server 2008（使用mysql都可以，只要是JDBC驱动的都行，不过修改一下数据库连接接口参数就行了）； （三）系统成果 登录界面 学生主页面 教师主页面 管理员主页面 （四）系统使用说明 下载项目代码 导入IDE，当时我开发的工具是myeclipse8.5，JDK1.7，tomcat6.0；eclipse其他都行，配置修改系统环境包文件（不同编程工具和系统配置环境都会有影响，按照提示补充或修改、缺失包文件就行了） 使用tomcat服务器启动 浏览器输入：http://localhost:8080/CurriculumEvaluationSystem 如果遇到什么问题，解决不了的，欢迎留言。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>后端Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java与Sql JDBC数据库连接及相关操作]]></title>
    <url>%2F2017%2F11%2F06%2F2017-11-06-java-web-sql-jdbc%2F</url>
    <content type="text"><![CDATA[本人第一次使用Java来连接 SQL Server Management Studio ，记录一下自己的连接过程，也是为了方便他人，减少不必要的麻烦。 （一）、下载安装数据库连接驱动 下载网址：https://www.microsoft.com/en-US/download/details.aspx?id=11774 点击下载 点击运行解压，解压路径默认或自定义，后面要用到 然后将解压好的文件打开到如图所示目录，根据自己安装或配置的JDK选择JRE文件夹打开（本人选择jre7），打开系统环境变量中，在classpath下添加sqljdbc41.jar的路径，如本人的路径是“F:\sqljdbc\sqljdbc_6.0\enu\jre7\sqljdbc41.jar;”(或者可直接复制sqljdbc41.jar到自己安装的jdk目录下) 设置SQL Server配置管理器，（不知道在哪里打开的，可以查询Sql Server Management Studio的文件位置，打开配置工具文件夹就可以找到了），打开MSSQL SERVER的协议，启动TCP/IP服务(打开的话在状态里会显示“已启用”)，重启服务器 （二）、配置myeclipse8.5 打开MyEclipse中的，Window –&gt; Preferences –&gt; Java –&gt; Installed JRES——&gt;选中相应的jdk（本人的是自己添加的）——&gt;edit如图所示： 选择如图的添加：自己之前解压的sqljdbc的jar包，如图本人选择的： 自己新建或选择一个项目右键单击目录窗口中, 选择Build Path –&gt; Configure Build Path…, 添加扩展jar文件，即把sqljdbc.jar添加到其中： （三）、测试连接数据库 编写java代码来测试连接数据库 12345678910111213141516171819202122232425 import java.sql.*; public class TestSqlJDBC &#123;/** * @param args */public static void main(String[] args) &#123; // TODO Auto-generated method stub String driverName = "com.microsoft.sqlserver.jdbc.SQLServerDriver"; //加载JDBC驱动 //注意端口号可能会冲突和DatabaseName需要链接的数据库名称 String dbURL = "jdbc:sqlserver://localhost:1433; DatabaseName=curriculumEvaluationSystem"; String userName = "sa"; String userPwd = "123456"; Connection dbConn; try &#123; Class.forName(driverName); dbConn = DriverManager.getConnection(dbURL, userName, userPwd); System.out.println("Connection Successful!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 运行会在Console界面提示：Connection Successful!则连接成功啦。 可能会遇到的问题及解决方式：（1）端口号冲突，自行修改SSMS的配置。（2）“Exception in thread “main” java.lang.UnsupportedClassVersionError: com/micro”，这个问题确实是由较高版本的JDK编译的java class文件试图在较低版本的JVM上运行产生的错误。需要更改JDK的版本。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Sql JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于SQL Server的Exec实现动态查询语句]]></title>
    <url>%2F2017%2F10%2F16%2F2017-10-16-sql-server-exec-query%2F</url>
    <content type="text"><![CDATA[在Sql Server查询语句中使用变量表示表名、列字段名等动态查询方式 前言今天看了《SQL Server数据库应用技术》的书，遇到的点疑惑也解决了，顺便分享一下。我本来也要想做一个JSP的动态网页，也要用到这个数据库的查询语句的知识点，所以正好实用。（注：需要点SQL Server基础知识） （一）exec与sp_executesql的区别EXEC和sp_executesql都是SQL Server提供的两种动态查询语句，各有各的优势,但是比较实用的还是后者，它提供了输入输出的接口，而exec是没有的，最重要的是可以重用执行。一般使用exec语句命令，要么是执行一个存储过程，要么是执行一个动态的查询过程。 （二）exec的使用 普通使用SQL语句查询可以使用以下3种方式： 123select * from TableNameexec('select * from TableName')exec sp_executesql N'select * from TableName' 字段名做变量查询 123declare @course varchar set @course = '课程名'Exec('select '+ @course +' from 课程表') 执行结果截图是： 需要注意的是： (2-1)要声明数据类型的长度，否则会报错 (2-2)字符串衔接没有使用空格 表名做变量查询 123declare @tableName varchar(50) set @tableName = '课程表'Exec('select * from '+@TableName) 注意事项跟上面一样 批处理查询（多个变量字符串） 12345declare @TableName varchar(50),@SqlString varchar(200),@CourseID int;SET @TableName = '课程表';SET @CourseID =1;SET @SqlString = 'select * from '+quotename(@TableName) +'where ID = '+cast(@CourseID as varchar(10))EXEC(@SqlString); 执行结果截图： 需要注意的是： (3-1)要将变量不是字符型的转换成字符型，否则会报错，使用cast()转换 (3-2)exec()括号内不允许使用多个变量串联的字符串，否则会报错 建议使用多个字符串的变量之间串联，如： 1exec(@SqlString1+@SqlString2+@SqlString3) exec()接口问题 简单的说就是不支持动态查询输入参数和输出参数，如： 1234declare @TableName varchar(50),@XXCourseID varchar(3);SET @TableName = '课程表';SET @XXCourseID ='5';exec('select * from '+quotename(@TableName) +'where 先修课ID = '+@XXCourseID) （三）sp_executesql的使用 简单的查询 12345declare @TableName varchar(50),@SqlString nvarchar(200),@CourseID int;SET @TableName = '课程表';SET @CourseID =1;SET @SqlString = 'select * from '+quotename(@TableName) +'where ID = '+cast(@CourseID as varchar(10))EXEC sp_executesql @SqlString 需要注意的是： (1-1)执行的查询语句字符串为三种类型：ntext、nchar、nvarchar，否则会报错 使用接口（支持参数的输入输出） @stmt = &lt;statement&gt;,–类似存储过程主体 @params = &lt;params&gt;, –类似存储过程参数部分 &lt;params assignment&gt;–类似存储过程调用 @stmt参数是输入的动态批处理，它可以引入输入参数或输出参数，和存储过程的主体语句一样，只不过它是动态的，而存储过程是静态的，不过你也可以在存储过程中使用sp_executesql; @params参数与定义输入/输出参数的存储过程头类似，实际上和存储过程头的语法完全一样； @&lt;params assignment&gt; 与调用存储过程的EXEC部分类似。 12345678declare @TableName varchar(50),@SqlString nvarchar(200),@CourseID int;SET @TableName = '课程表';SET @CourseID =1;SET @SqlString = 'select * from '+quotename(@TableName) +'where ID = @ID'EXEC sp_executesql @stmt=@SqlString, @params=N'@ID int', @ID=@CourseID 执行结果截图： 使用输出参数为调用批处理中的变量返回值 不做说明，目前暂时没有用到 参考文献 返回主页 兴百放’s Blogs]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆兼职——我们的故事]]></title>
    <url>%2F2017%2F10%2F07%2F2017-10-07-national-day-parttime-jobs%2F</url>
    <content type="text"><![CDATA[【世界那么大——可我偏偏认识你】赚的钱虽然不多，但是我们有缘走到了一起。每天纯纯碎碎为了工作，简简单单的快乐，让我们活得洒脱，过得充实，玩得任性，走得自如。这些日子让我明白：在一起的陪伴，胜过千言万语，而这终将是记忆中一片靓丽的风景。好怀念曾经的我们。 想起我们几个男生要准备去的前几天，很憧憬着那里——嘉华温泉酒店，算是五星级酒店吧。想了很多我们要带的东西，比如说带UNO、带扑克牌，带三国杀、带脸盘、带洗发水、带沐浴露、带洗衣粉等等。一大推乱七八糟的东西，毕竟要在那里住一个星期的。还要准备一些任职的东西，还要提前安排好自己的工作。真的好期待那里，不知道去到后会是怎么样的。 30号那天下午，倩仪姐来接牌坊我们，我们10个人出发了，4个女生，6个男生，不知道会发生什么样的故事，好期待，不过倩仪姐说会很忙，真的会很忙，:worried::worried::worried:，这个我真信了，不过就算这样样，来到来了，怕啥？不能怂，就是干！:confused::confused::confused:去到之后，倩仪姐带我们搞定一切事务及工作明天上班的工作安排。酒店很大，有点像小区，很豪华，工衣很好，这里的员工也都很年轻，这里的环境也很优美，反正比我们学校好很多，宿舍环境好的没话说，这里还可以看到白水寨的瀑布，很壮观。员工餐厅很小，但是饭菜好吃的一批（主要是跟学校饭堂比的），还有宵夜，还有水果。反正打饭菜都是自己动手，想吃什么就吃什么，想吃多少都可以的。过节还有福利呦:smirk::smirk::smirk:。 我们各自被安排好本分工作之后，这几天的工作性质是一样的。我被安排到上午去客房开荒（刚装修完的客房打扫卫生）3个小时，下午扮演卡通（扮演熊大）3个小时，晚上中餐传菜员3个小时。第一天上班，感觉身体被掏空:scream:，累的真的是躺下就能睡着了:sleeping:，可能第一次接触工作量太大的东西，真的是比工厂干活还累的那种，特别是开荒，扮演卡通。开荒容易手腿麻痹，但是可以偷懒呀（我们可以在一起讲话，去其他地方闲逛:wink::wink::wink:），扮演卡通主要是腰和腿都很麻痹，容易酸痛，关键是不容易偷懒，很悲催。晚上的传菜员还好，可以偷懒，工作有时也很闲，有时手臂也累的顶不住。第二天和第三天就开始慢慢适应了工作，虽然每天都很累，但是我们吃的很多，比我在饭堂吃的多了很多，要补回来的。每天也是一上班就希望快点下班，等不及了的那种。有一个男生干了两天就说要辞职了，结果真的走了，还一直抱怨太辛苦。还好，再苦再累，都挺的过来，我们几个人在一起都没有放弃，我相信我们不会忘记这段艰苦的岁月:sweat_smile::sweat_smile::sweat_smile:。 2号那晚，娜娜生日啦！我们一起帮她过生日，感觉自己几年没有吃生日蛋糕了，好美呦:smiley::kissing_closed_eyes:。 4号那晚，也就是中秋节。下班后，酒店举办的客人及员工参与的中秋节活动，奖品很丰富，还有免费的吃喝，哈哈哈。我们几个人，玩的好开心，可惜没怎么拍照。有猜灯谜、比慢骑单车、吹乒乓球过水杯、接扔公仔游戏四样。当然，主要是奖品啦。不好的就是：为什么要分员工区奖品和客人区奖品。还差距这么大，客人区奖品都是很有纪念性的东西，而员工区奖品都是生活用品。一直想要客人区奖品的二等奖熊熊公仔，真的好可爱呢，特别是棕褐色的，好暖心。 6号那晚，我们聚在一起吃了酒店西餐的自助餐，员工价88的，还可以哦，这一波不亏不亏:yum::yum::yum:。好多东西可以吃的，反正目前这是我吃的最豪华的自助餐了吧。甜品、牛排、羊排、鸡排、蒸包、饮料、小吃、关东煮、水果、海鲜等等呢。 吃的撑呀。还有，我们去看了草坪飞飞姐的举办的活动（也是我待过的部门），互动了很多，人也很多。听唱歌看跳舞，我们也用扑克牌玩了真心话大冒险，这个可以有，很刺激，还好大家都玩的开，很稳啦。这一晚，我们几个男生，也卧床谈了几个钟，我们明天就要回学校了，时间过的好快的，今晚也是我们在嘉华待过最特别的时光:relaxed::relaxed::relaxed:。 7号早上十点半，我们离开了嘉华，感谢嘉华，让我们走到了一起，让我们度过了难忘的日子，让我们留下了彼此的记忆。感谢一起兼职的我们，我们不负好人生时光。我们像是一“嘉”人了。When we were young…:no_mouth::no_mouth::no_mouth:]]></content>
      <categories>
        <category>我的大学</category>
      </categories>
      <tags>
        <tag>大三上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】对象（二）]]></title>
    <url>%2F2017%2F09%2F24%2F2017-09-24-study-js7-object-data%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第六章节对象第二节对象分类-内建对象-数据封装对象。 对象分类(一)、内建对象(一)、数据封装对象 Object对象 (1)定义：Object是Javascript中所有对象的父级对象，我们创建的所有对象都继承于此，包括内建对象 (2)语法： 1234//第一种：new Object([value]); //第二种：&#123;name:value,name:value...&#125;; (3)描述：Object 构造函数为给定的值创建一个对象包装。如果给定值是 null or undefined，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。当以非构造函数形式被调用时，Object 等同于 new Object()。 (4)属性：Object.prototype：可以为所有Object类型的对象添加属性 (5)方法 (5-1) Object.create():指定原型对象和属性创建一个对象。 语法：Object.create(proto,[propertiesObject]); 参数：proto:一个对象，作为新创建对象的原型，propertiesObject:一个对象值，可以包含若干个属性，属性名称为新建对象的属性名，属性值为那个属性的属性描述对象。 (5-2) Object.defineProperty():给对象添加/修改一个属性并指定该属性的配置 语法：Object.defineProperty(obj,prop,descriptor); 参数：obj：需要定义的对象，prop：需要定义或修改的属性名，descriptor：属性定义或修改的属性的描述 描述： 该方法允许精确添加或修改对象的属性。正常的属性添加通过赋值来创建并显示在属性枚举中（for…in 循环 或 Object.keys 方法）， 这种方式添加的属性值可能被改变，也可能会被 删除。该方法允许改变这些额外细节的默认设置。 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一； 数据描述符和存取描述符均具有以下可选键值： | 属性 | 作用 ||———–|————||configureable|当且仅当这个属性描述符值为 true 时，该属性可能会改变，也可能会被从相应的对象删除。默认为 false。||enumerable| 当且仅当该属性出现在相应的对象枚举属性中。默认为 false。||value|与属性有关的值。可以是任何有效的Javascript值。默认为undefined||writable|当且仅当可能用赋值运算符改变与属性相关的值。默认为false| 存取描述同时具有以下可选键值： | 属性 | 作用 ||———–|————||get|一个给属性提供getter的方法，如果没有getter则为undefined。方法将返回作用属性的值，默认为undefined||set|一个给属性提供setter的方法，如果没有setter则为undefined。该方法将受到作为唯一参数的新值分配给属性。默认为undefined| 注意：这些选项不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，你可能要在这之前冻结 Object.prototype，明确指定所有的选项，或者将 __proto__ =null;属性指向空。 (5-2-1)可选键值对应作用表： (5-3) Object.defineProperties():在一个对象上添加或修改一个或者多个自有属性，并返回该对象。 语法：Object.defineProperities(obj,props); 参数：obj:将要被添加属性或修改属性的对象，props:该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置 (5-4) Object.keys():方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致(两者的主要区别是for-in还会遍历除一个对象从其原型链上继承到得可枚举的属性) 语法：Object.keys(obj); 参数：返回该对象的所有可枚举自身属性的属性名 描述：Object.keys返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。如果你想获取一个对象的所有属性,，甚至包括不可枚举的，可以通过Object.getOwnPropertyNames()实现 (5-5) Object.getOwnPropertyNames():返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组 语法：Object.getOwnPropertyNames(obj); 参数：obj:要查看的对象 描述：Object.getOwnPropertyNames 返回一个数组，该数组对元素是 obj 自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过 for…in loop（或 Object.keys)）迭代该对象属性时一致。 数组中不可枚举属性的顺序未定义。 (5-6) Object.getOwnPropertyDescriptor()：返回指定对象上一个自有属性对应的属性描述符。(自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）) 语法：Object.getOwnPropertyDescriptor(obj,prop); 参数：obj:在该对象上查看属性，prop:一个属性名称，该属性的属性描述被返回 返回值：如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined 描述：该方法允许对一个属性的描述进行检索。在 Javascript 中， 属性 由一个字符串类型的“名字”（name）和一个“属性描述符”（property descriptor）对象构成。一个属性描述符是一个记录。 (5-7) Object.getPrototypeOf():返回指定对象的原型(也就是该对象内部属性[[Prototype]]的值) 语法：Object.getPrototypeOf(obj); 参数：要返回的对象 描述：如果参数不是一个对象类型，将跑出TypeError异常 (5-8) Object.freeze():冻结一个对象。冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说这个对象永远不能改变的。 语法：Object.freeze(obj); 参数：obj:要被冻结的对象 描述：冻结对象的所有自身属性都不可能以任何方式被修改。任何尝试修改该对象的操作都会失败，可能是静默失败，也可能会抛出异常（严格模式中）。数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。 (5-9) Object.isFrozen():判断对象是否已经被冻结 语法：Object.isFrozen(obj); 参数：obj:被检测的对象 描述：一个对象是冻结的（frozen）是指它不可扩展，所有属性都是不可配置的（non-configurable），且所有数据属性（data properties）都是不可写的（non-writable）。数据属性是值那些没有取值器（getter）或赋值器（setter）的属性。 (5-10) Object.preventExtensions():阻止对象扩展 语法：Object.preventExtensions(obj); 参数：obj:将要变得不可扩展的对象 描述：如果一个对象可以添加新的属性，则这个对象是可扩展的。preventExtensions 可以让这个对象变的不可扩展，也就是不能再有新的属性。需要注意的是不可扩展的对象的属性通常仍然可以被删除。尝试给一个不可扩展对象添加新属性的操作将会失败，不过可能是静默失败，也可能会抛出 TypeError 异常（严格模式）。 (5-11) Object.isExtensible():检测一个对象是否可扩展(是否可以在它上面添加新的属性) 语法：Object.isExtensible(obj); 参数：obj：需要检测的对象 描述：默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 __proto__属性可以被更改。Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）。 (5-12) Object.seal():可以让一个对象密封，并返回被密封之后的对象。密封对象是指那些不能添加新的属性、不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象 语法：Object.seal(obj); 参数：obj:要被密封的对象 描述：通常情况下，一个对象是可扩展的（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常（严格模式）。不会影响从原型链上继承的属性。但 __proto__ ( )属性的值也会不能修改。 (5-13) Object.isSealed():检测一个对象是否被密封sealed 语法：Object.isSealed(obj); 参数：obj:要被检测的对象 描述：如果这个对象是密封的，则返回 true，否则返回 false。密封对象是指那些不可 扩展 的，且所有自身属性都不可配置的（non-configurable）对象。 Object.prototype (1)JavaScript语言的所有对象都是由Object衍生的对象。 (2)所有对象都继承了Object.prototype的方法和属性，尽管它们可能被覆盖。 (3)属性：Object.prototype.constructor:返回一个指向创建了该对象原型的函数引用。 注意：该属性的值是那个函数本身，而不是一个包含函数名称的字符串。对于原始值（如1，true 或 “test”），该属性为只读。所有对象都会从它的原型上继承一个 constructor 属性。 (4)方法 (4-1) Object.prototype.hasOwnProperty():检测某个对象是否含有指定的自身属性。 语法：obj.hasOwnProperty(prop); 参数：要检测的属性名称。 描述：所有继承了 Object.prototype 的对象都会从原型链上继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。 (4-2) Object.prototype.isPrototypeOf():检测一个对象是否存在于另一个对象的原型链上。 语法：prototype.isPrototypeOf(object); 参数：prototype:检测该对象是否在参数object的原型链上。object:在该对象的原型链上搜寻。 描述：isPrototypeOf方法允许你检测一个对象是否存在于另一个对象的原型链上。 (4-3) Object.prototype.propertyIsEnumerable():检测指定的属性名是否是当前对象可枚举的自身属性。 语法：obj.propertyIsEnumerable(prop); 参数：prop:需要检测的属性名。 描述：每个对象都有 propertyIsEnumerable 方法。该方法可以判断出指定的属性是否是自身的可枚举属性，也就是说该属性是否可以通过 for…in 循环等遍历到。有些属性虽然可以通过 for…in 循环遍历到，但因为它们不是自身属性，而是从原型链上继承的属性,所以该方法也会返回false。如果对象没有指定的属性，该方法返回 false。 (4-4) Object.prototype.toString():返回一个代表该对象的字符串。 语法：object.toString(); 描述：当对象需要转换为字符串时，会调用它的toString()方法.默认情况下，每个对象都会从Object上继承到toString()方法，如果这个方法没有被这个对象自身或者更接近的上层原型上的同名方法覆盖(遮蔽)，则调用该对象的toString()方法时会返回”[object type]“，这里的字符串type表示了一个对象类型。 (4-5) Object.prototype.valueOf():返回的诗this值，即对象本身。 语法：object.valueOf(); 返回值：在其他类型的对象中，valueOf有可能返回一个不同的值。 Number对象 定义：Number JavaScript 对象是一个允许你处理数字值的包装对象。Number 对象使用Number() 构造器创建。 语法：new Number(value); 描述：如果参数无法被转换为数字，则返回 NaN。在非构造器上下文中 (如：没有 new 操作符)，Number 能被用来执行类型转换。 属性： | 属性 | 作用 ||———–|————||MAX_VALUE|最大的正数||MIN_VALUE|最小的正数||NaN|特殊的非数字值||NEGATIVE_INFINITY|特殊的负无穷大值，在溢出时返回||POSITIVE_INFINITY|特殊的正无穷大值，在溢出时返回||prototype|Number对象上允许的额外属性| 方法: | 方法 | 作用 ||———–|————||toFixed()|返回一个字符串，以定点数的形式来表示某一个数字，并进行四舍五入||toExponential()|返回一个字符串，以指数形式来表示某一数字||toPrecision()|返回一个字符串，既可以是指数型，也可以是小数型| Boolean对象 定义：Boolean对象是一个包装了布尔值的对象 语法：new Boolean([value]); 描述：如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false。其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象. 注意：原始的布尔值和Boolean对象是不一样的。任何值为 undefined 或者 null的对象, 包括值为false的Boolean对象, 在条件语句中,其值都将作为true来判断。不要通过新建Boolean对象的方法将一个非布尔值转换成布尔值。直接使用Boolean函数即可。 12var x=Boolean(exp);//这样使用var x=new Boolean(exp);//不要这样使用 如过你用一个对象作为Boolean对象的初始化值,则即使该对象是个值为false的Boolean对象,生成的Boolean对象的值也是true。不要在该使用Boolean原始值的地方使用Boolean对象。 String对象 定义：new String(s)构造函数，function String(s)转换函数 参数：存储到一个String对象中或转换为一个原始字符串的值 描述：当使用new操作符将String()作为一个构造函数使用时，它将返回一个String对象，内容为字符串s或s的字符串表示。当不带new操作符调用String()构造函数时，只是简单地将s转换为原始字符串并返回转换后的值 属性：length，得到字符串的长度 方法 String.charAt(n) 描述 取得一个字符串中的第n个字符 参数 希望返回的字符在字符串string中的索引 返回值 字符串string的第n个字符 注意 返回字符串中的第n个字符 字符串的起始点为0 如果不再字符串长度之内返回空字符串 String.charCodeAt(n) 描述 取得字符串中第n个字符的编码 参数 返回编码字符的索引 返回值 string中第n个字符的Unicode编码。返回的值为一个16位的整数，值在0~5535之间 注意 如果n为负数或大于等于字符串的长度，则返回NaN String.fromCharCode(c1,c2,...) 描述 从字符编码创建一个字符串 参数 指定待创建字符串中的字符的Unicode编码，一个或多个整数 返回值 一个新的字符串，内容为指定编码对应的字符 注意 这是一个静态方法，是String()构造函数的一个属性，而不是String对象的方法 String.concat(value,...) 描述 连接字符串 参数 一个或多个待连接的字符串 返回值 返回连接之后的字符串 注意 和+作用一样，连接字符串的 String.indexOf(substring[,start]) 描述 搜索一个字符串 参数 在string中搜索的字符串 一个可选的整数参数start。指定string中起始点。 返回值 在字符串string中start位置之后，substring第一次出现的位置，如果没找到返回-1 注意 String.indexOf()搜索指定的字符串，从前到后搜索 找到返回字符串第一次出现的位置 没找到返回-1 搜索的字符串按照字符串整体搜索 String.lastIndexOf(substring[,start]) 描述 从后面搜索 参数 一个可选的整数参数start。指定string中起始点。 在string中搜索的字符串 返回值 返回字符串最后一次出现的位置 String.localeCompare(target) 描述 使用本地特定的顺序比较两个字符串 参数 要与string使用区分地区设置的方式比较的字符串 返回值 string&lt;target,比0小的数 string&gt;target,比0大的数 string=target，返回0 注意 当使用&gt;或者&lt;操作符比较字符串的时候，是按照字符的Unicode编码进行比较的，不考虑本地的顺序，这种方式不准确 使用localeCompare()提供了一个根据默认的本地排序来比较字符串的方法，这个函数利用底层的操作系统提供的排序进行 String.match(regexp) 描述 找到一个或多个正则表达式匹配结果 参数 一个指定要匹配的模式的RegExp对象。如果如果这个参数不是一个RegExp对象，则它将先被传入RegExp()构造函数，后转换为RegExp对象 返回 一个包含撇皮结果的数组 String.repalce(regexp,replacement) 描述 替换匹配给定正则表达式的一个或多个子串 参数 指定了要替换的模式的RegExp对象。如果这个参数是一个字符串，它将用作一个要搜索的直接量文本模式；它将不会先转化为RegExp对象 replacement为替换文本的字符串，或者一个函数，用在替换时对应的替换文本 返回值 返回替换之后的内容 String.search(regexp) 描述 根据一个正则表达式查找 参数 一个RegExp对象，指定要在字符串string中查找的模式。如果这个参数不是一个RegExp，它将先传入RegExp()构造函数，后转换为一个RegExp对象 返回 string中第一个匹配regexp的子串的开始位置，如果没有找到匹配则返回-1 String.slice(start,end) 描述 截取字符串 参数 start起始点 end结束的位置 返回值 返回截取之后的字符串 String.substr(start,length) 描述 截取字符串 参数 start起始点 length截取字符串的长度 返回值 返回截取之后的字符串 String.substring(from,to) 描述 截取字符串 参数 起始点 结束点 返回值 返回截取之后的字符串 String.split(delimiter,limit) 描述 将一个字符串切分为一个由字符串组成的数组 参数 delimiter分隔符 limit指定已返回数组的最大长度。如果指定，则最多返回数量为这个数字的子串。如果没有指定，则将切分整个字符串，无论结果数组有多长 返回值 返回拆分之后的数组 String.toLowerCase() 描述 返回小写之后的字符串 返回值 返回小写之后的字符串 String.toUperCase() 描述 返回大写之后的字符串 返回值 返回大写之后的字符串 String.toLocaleLowerCase() 描述 返回小写之后的字符串 返回值 返回小写之后的字符串 String.toLocaleUpperCase() 描述 返回大写之后的字符串 返回值 返回大写之后的字符串 String.toString() 描述 返回对象的字符串 返回值 返回字符串 String.trim() 描述 去掉字符串两端的空白字符 返回 返回去除字符串两端空白的字符串 String.valueOf() 描述 返回对应的字符串 返回值 返回String的原始字符串值 String.link(url) 描述 link() 方法创建一个 &lt;a&gt; HTML 元素，用该字符串作为超链接的显示文本，参数作为指向另一个 URL 的超链接。 参数 任何能够指定 a 标签的 href 属性的字符串；它应当是有效的 URL（相对或绝对），任何 &amp; 字符将会被转义为 &amp;amp;，任何 &quot; 字符将会被转义为 &amp;quot;。 返回 返回创建好的链接 String.anchor(name) 描述 用anchor方法差un关键一个&lt;&lt;a&gt;HTML锚元素 参数 超链接的name属性 返回值 返回创建的锚点元素 Array对象 Function对象 定义 JavaScript中的Function对象，就是我们常说的函数对象。在JS中，所有的函数也是以对象的形式存在的。 语法 充当Function对象的构造函数使用，用于结合new关键字构造一个新的Function对象。 new Function( [ argName1 [, argName1 [, argNameN... [, funcBody ]]]] ) 当作普通函数使用，其行为与用法一(使用new关键字)完全一致，相当于用法一省略了new关键字。 Function( [ argName1 [, argName1 [, argNameN... [, funcBody ]]]] ) 返回值 Function()的返回值是Function类型，返回一个函数对象 注意 多数时候，你无需显示地通过new关键字来构造一个Function对象，因为在JavaScript中，你可以直接以function关键字形式声明函数 JavaScript在调用Function()构造函数时编译由该构造函数创建的对象。虽然它使您的脚本在运行时重新定义函数的情况下具有更大的灵活性，但它也会减慢代码的执行速度。为了避免减慢脚本速度，应尽可能少地使用Function()构造函数。建议优先考虑以function关键字的形式声明函数。 Function()会把传入的最后一个参数作为函数定义的执行代码，之前的所有参数均依次作为函数定义的参数。 如果没有指定任何参数，则表示该函数没有定义参数列表，函数的执行代码也为空 如果只指定了一个参数，则该参数将被视作函数的执行代码。如果你想定义一个参数、执行代码为空，请传入两个参数，第二个参数为空字符串即可：new Function(&quot;argName1&quot;, &quot;&quot;)。 属性 arguments 返回该函数执行时内置的arguments对象。 caller 返回调用当前函数的函数。 constructor 返回创建该对象的构造函数。 length 返回函数定义的参数个数。 方法 call() 调用当前Function对象，可同时改变函数内的this指针引用，函数参数一个个分别传入。 apply() 调用当前Function对象，可同时改变函数内的this指针引用，函数参数以数组或arguments对象的形式传入。 toString() 返回定义该Function对象的字符串。 valueOf() 返回Function对象本身。 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】对象（一）]]></title>
    <url>%2F2017%2F09%2F24%2F2017-09-24-study-js6-object-base%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第六章节对象第一节对象入门基础。 对象(一)、JavaScript对象基础 对象介绍 (1)Javascript对象是基本数据类型之一，是复合类型。(2)Javascript中几乎所有事物都是做对象。(3)Javascript的对象是拥有属性和方法的数据。 JavaScript 中的对象可以简单理解成”名称:值”对：(name:value) (1)JavaScript 中的对象与这些概念类似： Python 中的字典、Perl 和 Ruby 中的散列（哈希）、C/C++ 中的散列表、Java 中的 HashMap、PHP 中的关联数组 (2)名称：”名称”部分是一个 JavaScript 字符串 (3)注意： (3-1)、可以将属性名括在引号之间，这三种形式一样的： 123var obj=&#123;prop:1&#125;;var obj=&#123;"prop":1&#125;;var obj=&#123;'prop':1&#125;; (3-2)、必须放到引号之间： 如果属性名是Javascript的保留字之一 如果属性名种包含特殊字符(除字母、数字、下划线以外的字符) 如果属性名以数字开头 在ECMAScript5中，保留字可以用作不带引号的属性名，但对于ECMAScript3中必须用引号括起来 在ECMAScript5中对象直接量中的最后一个属性后的逗号将被忽略，在ECMAScript 3的大部分实现中也可以忽略这个逗号，但在IE中报错 值 “值”部分可以是任何 JavaScript 的数据类型——包括对象 创建对象的形式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1.通过对象字面量的形式创建对象var obj = &#123;&#125;; //没有任何内容的对象document.write(typeof obj);document.write('&lt;br/&gt;');// 也可以创建对象的时候赋值（键值对），注意逗号隔开var obj1 = &#123; x : 1, y : 2, z : 3&#125;;// 注意放在引号问题var obj2 = &#123; 'x': 1, "y": 2, 'for': "javascript关键字必须放在引号之间", username: "username", 'first-name': "dudu", married: true, test: null, test1: undefined, test2: 12.5, person: &#123; age: 18, xuehao: 123, name: "456" &#125;&#125;;// 2.通过new object()创建一个对象var obj3 = new Object(); //空对象var obj4 = new Date(); //创建日期对象var obj5 = new Array(); //创建数组对象var obj6 = new RegExp(); //创建正则表达式对象// 3.通过构造函数创建对象// 函数名称首字母大写，主要是分了区分内置函数function Test()&#123;&#125;var obj7=new Test();//也可以创建传参的构造函数var n=0,m=0;function Test1(a,b)&#123; // this.n=a; // this.m=b; n=a; m=b; document.write(n+"---"+m+'&lt;br/&gt;');&#125;var obj8=new Test1(123,456);document.write(typeof obj8);// instanceof检测对象是否是该函数构造器创建的document.write('&lt;br/&gt;');document.write(obj8 instanceof Test1);// 4.通过Object.create创建对象var obj9=Object.create(&#123;x:1&#125;);var obj10=Object.create(null);// 创建一个普通的空对象var obj11=Object.create(Object.prototype); 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《活着》-心有所感]]></title>
    <url>%2F2017%2F09%2F24%2F2017-09-24-alive-yuhua%2F</url>
    <content type="text"><![CDATA[一位真正的作家永远只为内心写作，只有内心才会真实地告诉他，他的自私、他的高尚是多么的突出。 简言《活着》，作者余华，第一次看他写的书。这本小说正如他所说的：写人苦难的承受能力，和对世界乐观的态度。也是最终想告诉我们一个道理：“人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。”看完这本书，内心是庆幸的，也是羞惭的。庆幸的是，自己可以读到这部作品，能感受到作者所传授的道理，更加庆幸的是，自己没有生活在作者笔下的那个年代，不然所经历的事情就不是这样了。羞惭的是，面对自己的处境和作为，跟小说主人公相比，差远了。不管是意志上，还是责任担当上，感觉自己好落寞，还欠缺很多需要锻炼。读完这部小说，可以让人回忆联想到自己的人生。不得不说这是一部高尚的作品。接下来，是自己此时此刻所想所感，一己之见，胡扯胡扯。不要看得太认真哈。 人物情节简介介绍一下小说主要人物：福贵（主角光环）、家珍（福贵妻子，很好的一个存在）、凤霞（福贵大女儿）、有庆（福贵小儿子）、王二喜（偏头，凤霞丈夫）、苦根（凤霞儿子）、队长（村里相当于村长的人）、龙二（赌博场老板）、春生（福贵战友）、老全（福贵战友）等，作者以一名游客的身份遇到老农民福贵，并由此回想起了他自己的过去…描述了中国过去五十多年的历史情形。 感动、成大三部曲(一)福贵家族破产前后福贵年轻的时候，家族里是一个地主，坐拥百多亩田地，可以说是村里最富有的家族，取了个老婆，叫家珍，是城镇上米店老板的女儿，也是貌美如花，关键是还温柔体贴善良持家（与当时的福贵性格状态形成对比）。他的一生可以说是衣食无忧的。可惜，财运不济，他因为迷上了赌博，而且还赊账的赌，最终被龙二下套，赌输了整个家族的财产，家里不得不卖掉房子和田地帮他还债，这也是他命运的转折点。从此他们一家搬到了以前小茅草屋，父亲也因此被气死，当时凤霞四岁多，家珍怀着有庆，母亲也病了。福贵一开始很消沉，毕竟是自己毁了家里，但还算是有点良知，知道悔改。 当父亲死后，家珍被娘家人接回去。不过，还好，家珍生完有庆半年后就回来了。福贵也知道勤勤劳劳在养家糊口，一家人也艰苦安稳过了一段时间。 (二)福贵被捉、白发送黑发还是命运不济吧，母亲病重，福贵拿着家珍给了两个银元去城里找医生，结果被国名党军队捉去拉大炮，一走就是两年，也认识了一起被捉的春生和老全，最终老全死了，春生也失踪了。福贵还好遇到了解放军的解救后回家了。回来后，母亲也在自己离开的两个月后死了，凤霞因为发烧导致又哑又聋。还好，有有庆，家珍陪着。那时候真的很穷，穷到了吃野菜，连几个月米都没有的日子。也赶上了村里人民公社、文化革命。福贵一家人还是艰苦的熬过了。 然而，不巧的事，又发生了，有庆在十三岁的时候医院抽血抽死了，听说是为了救县长夫人生小孩大出血。那时候县长就是春生。等到凤霞有个城里人二喜，相中结婚后。好日子不长，难产死了，生下苦根。家珍也在凤霞死后的三四个月后死了。苦根长大到四岁左右，二喜也在一次意外中死了。可悲的是，苦根也在7岁多的时候一次高烧死了。面对着一系列的打击与心痛，现实终究是现实，福贵还是坚持顽强的活下来了。 (三)余生还活着尽管命运爱捉弄福贵，但是福贵没有放弃活着，还是辛辛苦苦耕作，攒了钱买了一头跟自己一样老了牛，并取名叫做福贵，陪自己度过余生。福贵晚年唱道的歌——少年去游荡，中年想掘藏，老年做和尚。也许这就是他最平凡也是最不平凡的一生。 总言很喜欢余华这种写作的风格，描绘了很多常人的心里，抠入人心。每个人都有自己的命运，都有自己的归宿。也许一个人有时候活着很难，真的很难，毕竟现实是残酷的。特别是无牵无挂的时候，自己都不知道怎么度过每一天。我想：客观的压力再大，环境再怎么恶劣，只要自己意志够坚定，该面对的还是要面对，不是顺其自然，而是乘分破浪，活出自己，哪怕只剩自己了，也要好好的。因为你身上寄予了你爱的人的希望。这就是我所领悟到的。谢谢阅读。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半夜有感——我爱我自己了]]></title>
    <url>%2F2017%2F09%2F18%2F2017-09-18-feel-at-midnight%2F</url>
    <content type="text"><![CDATA[没有深夜痛哭过的人，不足以谈人生。——柴静 昨晚，心很累又一次感觉自己心累了，看来最近我到底经历了什么，让自己那么不舒服、那么的不顺心。自从今年八月份开始，一切安定的局面都被打破了，发生了太多事了，本来以为自己可以扛过来的，结果还是变成了心结，每每想起，都有一种难以启齿的痛。也许，这就是我宿命的一部分吧。有时候不是自己想太多，而是真的认真了，却换来自己被伤害的结果，然后自己感觉就是无助、无奈、无何的人，真的不知道怎么做才好。我不知道接下来是顺其自然好，还是自己默默承受好，真希望时间可以过得快点，也许时间会告诉我，不管是不是我想要的答案，经历过岁月的沉淀，一切都会变得那么释然的。这样最好不过了。这三件事是这样的： 恋人变伤人也许我不知道甚至不懂、不理解，曾经那么喜欢的她到底经历了什么，可以让她从突然出现在我的世界里然后又突然消失。呵呵，感觉好好玩的样子。有种玩过山车的意外。一切都这么毫无节奏的发生了。我以为，两个人在一起，彼此相爱了，就算外界客观因素干扰再大，也会抵不过两人真挚的心，结果我想的还是错了，看来是我太无知了。果然，爱的越深，伤的也越深。开学这段时间，真的好可悲，曾有这么一刻是想到的：失去她，就像失去了全世界一样。算啦，心清了，自然定了。 舍友变冷漠大二换了新宿舍，也换了舍友。那时候我们几个，其乐融融，相依相靠，就像兄弟一样。几个人经常在一起去吃饭、去上课。然而好景不长。也许经过一段时间的相处，随着学识和阅历，变得各个深沉了。特别有一个舍友，之前跟我很亲密，很友好。喜欢跟我学弄发型，睡觉前喜欢跟我谈人生，我也跟着他学做菜，一起买一样的风衣，一样的皮鞋。可惜，我们因为上学期彼此吵过一次架，就回不去曾经的那种关系了。虽然现在时不时会说几句，但也是没有那种情调了，真的变了，变得互相都不想搭理对方。我也变的在这个宿舍，除了一些问候语之外，想不到跟他们几个说什么了，可能还有一些学习的交集吧。自己喜欢变得沉默，变得一个人独处了，一个人默默的做自己的事，变得没那么爱讲话了。回忆起来，真的变化了好多，也许这就是成长吧。 亲朋不亲脑这个说起来，也是一个悲催的故事，原本我跟他是很要好的亲密朋友，他也为人比较正直，但是就是处事很不用心，说话也开玩笑和爱吹牛逼。感觉他就是别人眼中的老好人和小丑吧。但是我跟他还有一个人，三个人是很要好的朋友，他有点让我佩服的就是，我能看到他对我的真诚，不然那也许我跟他也发展不到这个地步，本来我就是跟他志不同、道不合的人。所以，我一直想帮他做一些改变，让他变的有人格魅力的男人，这样他会变的更好。但是，也许他做的事，很多令我不屑一顾，但我能忍都忍了，毕竟认识这么久了是吧，又不是第一次。昨晚，真的忍不了，在我面前说一套，在别人面前又是一套，他还是改不了他的坏毛病，以至于我错过了机会，之前有跟他说过，但是他就是想不通，也许这就是他吧！我不知道我什么时候能真的不想鸟他了，但是我发现不可能像以前一样对他了，可能他不知道这是无形对我的伤害，但是真的，我不想让自己那么心累，放开一点好。 还能坚持多久经历过这三件事，我想自己会改变很多。不知道自己还能坚持多久，可能总有一天会爆发出来吧，如果我坚持不下去了，不是我真的放下了，而是我不想伤害自己了，真的需要自己一个人好好享受自己，爱自己了，不想去理解、包容、去管别人的是与非了，就想自己好好的对自己，好好珍惜在乎我的人，好好爱身边一直陪伴我的人，最重要的是，要让自己每天都是最好的状态去迎接新的一天，不管过去了，未来才是最重要的。爱自己，做自己，最好成就自己。 最后，我相信，世界也会给予我一份温柔。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】函数]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-study-js5-function%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第五章节函数。 函数(一)、什么是函数 函数是完成某一功能的代码段，函数是可重复执行的代码段，函数方便管理和维护。 (二)、自定义函数 通过 function 关键字 1234 function 函数名称([参数,...])&#123;代码段;return 返回值; &#125; 注意： (1)、函数名称不要包含特殊字符。 (2)、函数名称最好含义明确。 (3、)函数名称最好遵循驼峰标记法或者下划线法。 (4)、函数名称严格区分大小写。 (5)、函数名称如果重复会产生覆盖。 (6)、函数可以有参数也可以没有参数，可以有一个参数也可以有多个参数。 (7)、函数通过return加返回值，如果没有return 默认返回undefined。 (8)、函数不调用不执行。 匿名函数 函数表达式可以存储在变量中，变量也可以作为一个函数使用，可以将匿名函数作为参数传递给其它函数，接收方函数就可以通过所传递进来的函数完成某些功能，可以通过匿名函数来执行某些一次性的任务。 通过 Function() 构造函数 通过内置JavaScript函数构造器(Function())定义 12var myFunction=new Function('a','b','return a+b');var myFunction=function(a,b)&#123;return a+b;&#125;; 注意：以上两种方式是等价的，尽量避免使用 new 关键字。 (三)、调用函数 作为一个函数调用 (1)、通过 函数名称() 进行调用，如果有参数传递相应参数即可。 (2)、在HTML中默认的全局对象是HTML页面本身，所以函数是属于HTML页面。在浏览器中的页面对象是浏览器窗口(window对象).所以函数会自动变为window对象的函数。也可以通过 window.函数名称()进行调用。 12345678910111213141516171819202122 //函数名称严格区分大小写function TEST() &#123; alert("hello king");&#125;//TEST();//函数名称重复会产生覆盖//test();function test() &#123; alert('hello maizi');&#125;//test();function test() &#123; // alert("this is a test!");&#125;// test();function test1(num1, num2) &#123; return num1 * num2; // 程序执行碰到return就返回结束，后面程序将不会执行 return 123; return "456king";&#125;// alert(test1(12,56)); 全局对象 当函数没有被自身的对象调用时，this的值就会变成全局对象。在web浏览器中全局对象是浏览器窗口window对。函数作为全局对象调用，会使this的值称为全局对象。使用window对象作为一个变量容易造成程序崩溃。 函数作为方法调用：可以将函数定义为对象的方法进行调用。 使用构造函数调用函数：如果在函数调用前使用了new关键字，则调用了构造函数。 作为回调函数调用函数：call()、apply()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 // 回调函数的应用，注意参数名function calc(x, y) &#123; return x() + y();&#125;function test6() &#123; return 123;&#125;function test7() &#123; return 123;&#125;document.write(calc(test6, test7) + '&lt;br/&gt;');//另一种奇葩的回调函数document.write(calc(function () &#123; return 8;&#125;, function () &#123; return 12;&#125;));// 举一个案例应用：两个函数，将改为一个回调函数document.write("&lt;hr color='yellow' /&gt;");function arr(a, b, c) &#123; var arr1 = []; for (var i = 0; i &lt; arguments.length; i++) &#123; arr1[i] = arguments[i] * 2; &#125; return arr1;&#125;function add(z) &#123; return z + 1;&#125;var arr2 = [];arr2 = arr(123, 456, 789);for (var i = 0; i &lt; arr2.length; i++) &#123; document.write(arr2[i] + "&lt;br/&gt;");&#125;for (var i = 0; i &lt; arr2.length; i++) &#123; arr2[i] = add(arr2[i]);&#125;document.write("&lt;hr color='red'/&gt;");for (var i = 0; i &lt; arr2.length; i++) &#123; document.write(arr2[i] + "&lt;br/&gt;");&#125;//注意这里将改为使用一个回调函数callbackfunction CBfunction(a, b, c, callback) &#123; var arr3 = []; for (var i = 0; i &lt; arguments.length - 1; i++) &#123; arr3[i] = callback(arguments[i] * 2); &#125; for (var i = 0; i &lt; arr3.length; i++) &#123; document.write(arr3[i] + '&lt;br/&gt;'); &#125;&#125;function addOne(z) &#123; return z + 1;&#125;document.write('&lt;hr/&gt;');CBfunction(123, 456, 789, addOne);document.write('&lt;br/&gt;');// 也可以使用匿名函数CBfunction(123, 456, 789, function (z) &#123; return z + 2&#125;);// 默认的两个回调函数call()（传递的事参数）、apply()（传递的是数组）function CB(x, y) &#123; return x * y;&#125;document.write('&lt;br/&gt;');document.write(CB.call(CB, 12, 12));document.write('&lt;br/&gt;');var paraNum = [123, 456];document.write(CB.apply(CB, paraNum) + '&lt;br/&gt;');// 自调函数示例，注意括号，只能执行一次( function () &#123; document.write("This is a test" + "&lt;br/&gt;"); &#125;)();// 传递参数的自调函数( function (a, b) &#123; document.write(a * b + '&lt;br/&gt;'); &#125;)(123, 456); (四)、参数 函数可以有参数也可以没有参数，如果定义了参数，在调用函数的时候没有传值，默认设置为undefined。 1234567 // 使用传参默认值效果function test2(num1, num2) &#123; num1 = num1 || 100; num2 = num2 || 10000; return num1 + num2;&#125;document.write(test2()); 在调用函数时如果传递参数超过了定义时参数，js会忽略掉多余参数。 12345 // 传过多的参数function test3(num1, num2) &#123; return num1 + num2;&#125;document.write("&lt;br/&gt;" + test3(1, 2, 3, 4, 5, )); js中不能直接写默认值，可以通过 arguments 对象来实现默认值效果。 123456789101112 // 设置默认值function calc(num1, num2) &#123; if (num1 === undefined) &#123; num1 = 0; &#125; num2 = num2 === undefined ? 0 : num2; return num1 + num2;&#125;document.write(calc());document.write('&lt;br/&gt;');document.write(calc(12, 56));document.write('&lt;hr/&gt;'); 可以通过 arguments 对象实现可变参数的函数。 123456789101112131415161718192021222324252627282930313233343536373839// 使用arguments下标索引值设置参数值,它是一个数组function calc1(num1, num2) &#123; document.write(arguments[0]); document.write('&lt;br/&gt;'); document.write(arguments[1]); document.write('&lt;hr/&gt;'); num1 = arguments[0] ? arguments[0] : 0; num2 = arguments[1] ? arguments[1] : 0; return num1 + num2;&#125;document.write("&lt;hr color='red'/&gt;");document.write(calc1());document.write('&lt;br/&gt;');document.write(calc1(465, 123));// arguments可变参数传输功能：传递多个参数，而不用设置函数参数名function test() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125;document.write("&lt;hr&gt;" + test(456, 132, 7645, 44323));// 使用arguments求传参的最大值function calc2() &#123; var max = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; if (max &lt;= arguments[i]) &#123; max = arguments[i]; &#125; &#125; return max;&#125;document.write("&lt;hr color='red'/&gt;");document.write(calc2(123, 456, 1212, 45646, 123456, 12341)); 通过值传递参数在函数体内对变量做修改不会影响变量本身。 通过对象传递参数在函数体内对变量做更改会影响变量本身。 (五)、变量的作用域 局部变量：在函数体内声明的变量，仅在函数体内可以使用。 全局变量：函数体外声明的变量，在变量声明开始到脚本结束都可以是使用。 12345678910111213 // 局部变量function test() &#123; var x = 5; alert("这个是局部变量：" + x);&#125;test();// alert(x); 会报错，证明是不存在的function test2() &#123; y = 10; alert("不用var声明的变量：" + y);&#125;test2();alert("这个是全局变量：" + y); 12345678910111213141516171819202122 // 再次理解变量的作用域var x = 12, y = 14;function test3(x, y) &#123; document.write("输出a的值为：" + a + "&lt;br/&gt;"); //没有定义 document.write("函数体内x的值：" + x + "&lt;br/&gt;"); // 这是一个全局变量,没有用var声明的变量 z = x + y; // 注意这是一个局部变量 var zz = x + y; x = x + y; var a = 132; document.write("输出定义后的a的值为：" + a + "&lt;br/&gt;"); document.write("输出方法体内改变的值：" + x + "&lt;br/&gt;"); return z;&#125;test3();document.write("&lt;hr/&gt;");test3(x, y);document.write("&lt;br/&gt;" + "输出三个全局变量的值：" + "x=" + x + "," + "y=" + y + "," + "z=" + z + " 输出一个局部变量会报错");// 注意全局变量容易被方法体内声明的全局变量覆盖 注意：尽量控制全局变量的数量，容易引发bug，最好总是使用 var 语句来声明变量。 (六)、JavaScript全局函数 parseInt(string,radix):返回转换成整数的值 1234567891011 // parseInt()默认转换成十进制数，字符转换取合法部分前面的，会忽略空格document.write(parseInt('456'));document.write('&lt;br/&gt;');document.write(parseInt('789abc') + '&lt;br/&gt;');document.write(parseInt(' 123 456') + '&lt;br/&gt;');document.write(parseInt('F') + '&lt;br/&gt;');// 注意这里输出的数，填上基数之后document.write(parseInt('F', 16) + '&lt;br/&gt;');document.write(parseInt('17', 8) + '&lt;br/&gt;');// 注意：默认开头的0x的数（0一个是零不是字母o），默认转换十六进制数，document.write(parseInt('0xfff') + '&lt;br/&gt;'); 注意： (1)、当参数radix的值为0，或者没有设置这个参数，parseInt()会根据string来判断数字的基数 (2)、当忽略radix，JavaScript默认数字的基数规则为： 如果string以0x开头，parseInt()会把string的其余部分解析为十六进制的整数。 如果string以0开头，那么ECMAScript v3允许parseInt()的一个实现把其后的字符解析为八进制或十六进制的数字。 如果string以1~9的数字开头，parseInt()将把它解析为十进制的整数。 字符串如果以合法字符开始，截取合法字符。 开头和结尾的空格是允许的。 如果字符串的第一个字符不能被转换为数字，parseInt()会返回NaN。 在字符串以”0”为开始时旧的浏览器默认使用八进制基数。ECMAScript 5，默认的是十进制的基数。 parseFloat(string):返回转换成浮点型的值 该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 12345 // 转换成浮点数document.write(parseFloat('0.23') + '&lt;br/&gt;');document.write(parseFloat('12.3456abc') + '&lt;br/&gt;');document.write(parseFloat(' 4.56') + '&lt;br/&gt;');document.write(parseFloat('abc4.56') + '&lt;br/&gt;'); isFinite(value):检测某个是是否是无穷值 如果number是NaN或者+Infinity或者-Infinity的数，isFinite()返回false。 12345 // 通过isFinite()检测是否是无穷值var x = 123e123;document.write(isFinite(x) + '&lt;br/&gt;');x = Infinity;document.write(isFinite(x) + '&lt;br/&gt;'); isNaN(value):检测某个值是否是NaN isNaN()检测是否是非数字值，如果值为NaN返回true，否则返回false`。 12345678 // 通过isNaN()检测是否是一个数值x = undefined;document.write(isNaN(x) + '&lt;br/&gt;');x = NaN;document.write(isNaN(x) + '&lt;br/&gt;');x = parseInt('abc456');document.write(x + '&lt;br/&gt;');document.write(isNaN(x) + '&lt;br/&gt;'); encodeURI(uri):将字符串编码为URI 注意：使用 decodeURI()方法可以编码URI（通用资源标识符:UniformResourceIdentifier,简称”URI”)。对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI()函数是不会进行转义的：, / ? : @ &amp; = + $ #(可以使用 encodeURIComponent()方法分别对特殊含义的 ASCII 标点符号进行编码。)。 decodeURI(uri):解码某个个编码的URI encodeURIComponent(uri):将字符串编码为URI组件 注意：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( )其他字符（比如 ：; / ? : @ &amp; = + $ , #这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 decodeURIComponent():解码一个编码的URI组件 123456789101112 // 封装字符串URL编码：注意不会转义的特殊字符和ASCIIvar url = "http://wwww.super456.github.io?qs=this is a test&amp;para=4+5+6";var res = encodeURI(url);document.write(res + '&lt;br/&gt;');// 解析URL编码var res1 = decodeURI(res);document.write(res1 + '&lt;br/&gt;');// 讲字符串URL编码为URI组件var res2 = encodeURIComponent(url);document.write(res2 + '&lt;br/&gt;');var res3 = decodeURIComponent(res2);document.write(res3 + "&lt;br/&gt;"); escape():对字符串进行编码 注意：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码：* @ - _ + . /。其他所有的字符都会被转义序列替换。escape()函数不能用于编码 URIs(通用资源标识符（UniformResourceIdentifier,简称”URI”））。 unescape():解码由escape()编码的字符串 1234567891011 // 编码字符串var str = "hello world";var res4 = escape(str);document.write("&lt;hr/&gt;");document.write(res4 + '&lt;br/&gt;');var res6 = unescape(str);document.write(res6 + "&lt;br/&gt;");str = "1061996681";var res5 = escape(str);document.write(res5 + '&lt;br/&gt;'); eval():将JavaScript字符串当作脚本来执行 1234 // eval()该函数会将字符串当做脚本来执行：慎用，危险！eval('var i=456');// 相当于声明了一个变量document.write(i + "&lt;br/&gt;"); 注意：如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。eval()函数是一种由函数执行的动态代码，比直接执行脚本慢很多，慎重使用eval()函数,尽量不用，保证程序的安全性。 Number(object):把对象的值转换为数字 1234567891011 // number()该函数将对象转换为数字，如果不是则返回NaNvar num = Boolean(123);document.write(Number(num) + "&lt;br/&gt;");num = "456";document.write(Number(num) + "&lt;br/&gt;");num = "abc456";document.write(Number(num) + "&lt;br/&gt;");// 注意如果是日期的话则转换成1970年1月1日至今的好秒数document.write("&lt;hr color='red'/&gt;");var date = new Date();document.write(Number(date) + "&lt;br/&gt;"); 注意：如果对象的值无法转换为数字，Number()函数返回NaN，如果参数的Date对象，Number()返回从1970年1月1日到现在所经历的毫秒数。 String():把对象的值转换为字符串 String()函数返回与字符串对象的toString()方法值一样。 123456 // String()和toString()两者方法一样：将对象转换成字符串var string = null;string = undefined;string = 456;string = NaN;document.write(String(string) + '&lt;br/&gt;'); (七)、特殊形式的函数 函数也是数据：JavaScript中的函数也是一种数据类型，只不过这种特殊类型有两个重要的特性；他们所包含的是代码，他们是可以执行的。 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】数据类型与变量]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-study-js2-data-type-variable%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第二章节数据类型与变量。 数据类型与变量(一)、原始数据类型 数值型 JavaScript中的数值包含整数和浮点数，所有数值都以双精度浮点型来表示。双精度浮点数可以表示-2的53次方到2的53次方的整数，也可以表示为正负1.7976的10的308次方的最大值和正负2.2250乘以10的-308次方的浮点数。 (1)十进制数：12、1.2、-23、.222e33、-1.3e3、3.E-2、12e+20 (2)十六进制：0x0、0XABCDEF、0x1a2b3c4d (3)八进制数：00、0123、0241234 (4)特殊值：Infinity无穷大-&gt;当一个数值或数值表达式的值超出了可表示的最大值的范围，将被赋值为Infinity。可以有无穷大Infinity，也可以有无穷小-Infinity（如：1.79e309、-1.79e309）、NaNNaN-&gt;代表Not a Number。当一个Undefined表达式的结果为数值型数据时，该数值型就是NaN值。NaN是唯一一个不能和自身做比较的值（如：0/0）可以通过isNaN()检测值是否为NaN 字符串型 (1)定界符：&quot;&quot;|&#39;&#39; (2)转义符：\n-&gt;回车换行、\r-&gt;换行、\t-&gt;水平制表符、\&quot;-&gt;”、\&#39;-&gt;’ (3)布尔类型：true或false (二)、复合数据类型 重点：对象(object)、数组(array)、函数(function) (三)、特殊数据类型 无定义数据类型undefined：undefined用来表示不存在的值或者尚未赋值的变量。对一个变量只声明不赋值或者赋予一个不存在的属性值，都会使这个变量的值为Undefined 空值null：null表示空值，表示什么都没有，相当于一个占位符。null和undefined的区别就是undefined表示变量未被赋值，而null表示变量被赋予了一个空值。 (四)、变量 声明变量 (1)通过var关键字声明变量 (2)可以声明变量的同时给变量赋值 (3)可以一次声明一个变量也可以一次声明多个看变量 注意：如果只声明变量未对其赋值，默认值为undefined，如果变量重名产生覆盖。 (4)格式注意：变量严格区分大小写、变量名称不要包含特殊字符、变量名称最好遵循驼峰标记法或者下划线法、变量名称最好含义明确 变量在内存中的存储与释放：收集方式、收集内容、回收算法。 (五)、类型转换 隐式转换 (1)、转换成布尔类型假： | 属性值 | 转换成值 ||———–|————||undefined|false||null|false||数值型0或0.0或NaN|false||字符串长度为0|false||其它对象|true| 12345678var test = Boolean(0);test = Boolean(-0);test = Boolean(NaN);test = Boolean(undefined);test = Boolean('');test = Boolean(0.0);test = Boolean('0');document.write(test + '&lt;br/&gt;'); (2)、转换为数值型数据： | 属性值 | 转换成值 ||———–|————||undefined|NaN||null|0||true|1||false|0||内容为数字|数字，否则转换成NaN||其它对象|NaN| 12345678910test = Number(12);test = Number(232.3);test = Number(true);test = Number(false);test = Number(undefined);test = Number(NaN);test = Number(null);test = Number('3king');test = Number('324');document.write(test + '&lt;br/&gt;'); (3)、转换为字符串型数据： | 属性值 | 转换成值 ||———–|————||undefined|”undefined”||null|”NaN”||true|”true” ||false|”false”||数值型|NaN、0或者与数值对应的字符串||其它对象|如果存在这个对象则转换为toString()方法的值，否则转换为Undefined| 123456789test = String(1234);test = String(23.34);test = String('this is a test');test = String(true);test = String(false);test = String(null);test = String(undefined);test = String(NaN);document.write(test + '&lt;br/&gt;'); 显示转换 (1)、转换成数值： | 属性值 | 转换成值 ||———–|————||Number函数|强制转换成数值||数值|转换成原来的值||字符串|如果可以解析为数值，则转换成数值；否则转换成NaN或者0||true|1||false|0||undefined|NaN||null|0| (3)、转换成整型：praseInt() 123456789test = parseInt('123');test = parseInt('234', 0);test = parseInt('0xabcdef');test = parseInt('012344');test = parseInt(45, 16);test = parseInt('3ki23ng');test = parseInt('true');test = parseInt(true);test = parseInt(' 35 6 a '); (4)、转换成浮点型：praseFloat() 12345test = parseFloat('123.34abc');test = parseFloat('123');test = parseFloat('sdf');test = parseFloat(' 2e3a');document.write(test+'&lt;br/&gt;'); 注意：Number函数将字符串转换为数值比praseInt函数严格很多。基本上只要有一个字符无法转换成数值，整个字符串就会被转换成NaN。 (5)、转换成字符串： (5-1)、通过String函数转换成字符串 属性值 转换成值 数值 数值本身 字符串 字符串本身 true “true” false “false” undefined “undefined” null “null” 12var ty = String(456);document.write(ty); (5-2)、转换成字符串型：toString() (6)、转换成布尔类型： (6-1)、通过Boolean函数强制转换成布尔值 属性值 转换成值 0、-0 false NaN false 空字符串 false undefined false null false 12var ty= Boolean(0.0);document.wirte(ty); 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】运算符与表达式]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-study-js3-operators-expressions%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第三章节运算符与表达式。 运算符与表达式(一)、表达式 表达式是用于JavaScript脚本运行时进行计算的式子，可以包含常量、变量、运算符 (二)、运算符 算术运算符：+、-、*、/、%、++、--、++、--分为前缀形式和后缀形式 前缀形式先加减1在执行，后缀形式先执行再加减1。 12345678910document.write("&lt;br/&gt;");document.write(r + p);document.write("&lt;br/&gt;");document.write(r * p);document.write("&lt;br/&gt;");document.write(r - p);document.write("&lt;br/&gt;");document.write(r / p);document.write('&lt;br/&gt;');document.write(-r % p); 注意： +号用来连接两个字符串，只要+连接的操作数中有一个是字符串型，Js就会自动把非字符串型数据作为字符串型数据来处理。Js代码的执行顺序是从左到右，所以在+连接的表达式中，遇到字符串型数据之前，所有出现的数值型数据(或者可以自动转换为数值型的数据)仍被作为数值来处理。为了避免这种情况，我们可以在表达式前拼一个空字符串。 字符连接符：通过 + 连接字符串 1234567891011document.write('&lt;br/&gt;');document.write(r + '8');document.write('&lt;br/&gt;');// 注意结果是r+p再拼接5djaoidocument.write(r + p + "5djaoi");document.write('&lt;br/&gt;');document.write("hello wordl" + "465");document.write("&lt;br/&gt;");document.write(1123 + "fkasdjl");document.write('&lt;br/&gt;');document.write('' + r + num1); 赋值运算符：=、+=、-=、*=、/=、%=、.= 123var a = 5;a += 8; //a=a+8document.write('&lt;br/&gt;' + a); 比较运算符：&gt;、&gt;=、&lt;、&lt;=、==、!=、===、!== 1234document.write('&lt;br/&gt;');document.write(a &gt; num1);document.write('&lt;br/&gt;');document.write(1 === true); 注意：比较运算符的结果为布尔类型，==只比较值是否相等、===比较值和类型。 逻辑运算符：&amp;&amp;、||、! 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 逻辑运算符：短路现象//要求两个表达式为true，结果才是true// alert(true &amp;&amp; true);// alert(true &amp;&amp; false);// alert(false &amp;&amp; true);// alert(false &amp;&amp; false);//如果第一个表达式为false，整个结果为false，就把第二个表达式短路了// 逻辑与document.write("&lt;br/&gt;");var i = 0, j = 1;if (i-- &amp;&amp; j++) &#123; document.write("hello");&#125; else &#123; document.write("world");&#125;document.write('&lt;br/&gt;');document.write(i);document.write("&lt;br/&gt;");// j++被短路未执行document.write(j);// 逻辑或//两个表达中有一个为true，整个结果为true// alert(true || true);// alert(true || false);// alert(false || true);// alert(false || false);//如果第一个表达式为true，整个结果为true，把第二个表达式短路了var a = 0, b = 1;if (a-- || b++) &#123; document.write("&lt;br/&gt;"); document.write("true");&#125; else &#123; document.write('&lt;br/&gt;'); document.write("false");&#125;document.write("&lt;br/&gt;");document.write(a + " " + b);// 逻辑非：取反的作用var takeback = true;document.write(!takeback + '&lt;br/&gt;'); 注意：逻辑运算符的结果为布尔类型，&amp;&amp;如果第一个表达式为false，造成短路，||如果第一个表达式为true,造成短路。 三元运算符：exp1?exp2:exp3 12345678910 /*if(exp)&#123; exp为true的代码段;&#125;else&#123; exp为false的代码段;&#125;exp1?exp2:exp3;*/ var sanyuan = a &gt; b ? "aa" : "bb"; document.write("&lt;br/&gt;"); document.write(sanyuan); 其它运算符 (1)、逗号运算符：逗号用来将多个表达式连接为一个表达式，新表达式的值为最后一个表达式的值，多用在变量声明处 1234// 逗号表达式：douhoa的值为最后一个表达式的值var douhoa = (a = 8, b = 9, c = 389);document.write("&lt;br/&gt;");document.write(douhoa); (2)、void运算符：void运算符用来指明一个表达式无返回结果 1234// void运算符：void（）；var voidreturn = void(a = 2);document.write("&lt;br/&gt;");document.write(voidreturn); (3)、typeof运算符：typeof运算符用来返回一个字符串，返回的是操作数的数据类型 123// typeof 运算符返回变量的类型var test=NaN;document.write(typeof test); (三)、运算符的优先级 默认优先级图表： 通过 () 改变优先级 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】流程控制语句]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-study-js4-flow-control%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习js基础第四章节流程控制语句。 流程控制(一)、条件语句 if(exp)执行一句代码 if(exp){执行代码段;}代码片段 if(exp){exp为true执行代码段}else{exp为false执行代码段;}代码片段 12345678910// 条件语句走势if (6 &gt; 9) &#123; document.write("hello");&#125; else &#123; document.write("world");&#125;document.write('&lt;br/&gt;');document.write();document.write("&lt;hr color='red'/&gt;"); if...else if...代码片段 123456789// 多个条件表达式 else if符合一个，程序跳出条件判断var a = "dudu";if (a == "456") &#123; document.write("hello 456");&#125; else if (a == "dudu") &#123; document.write("hello dudu");&#125; else if (a == "dudu456") &#123; document.write("hello dudu456");&#125; if嵌套 1234567891011121314151617181920212223 // 多层嵌套if-else语句 var username='king',age=22,sex='男';if(3&gt;1)&#123; document.write('aa&lt;br/&gt;'); if(username=='king')&#123; document.write('hello King&lt;br/&gt;'); if(age&gt;=18)&#123; document.write('成年人&lt;br/&gt;'); if(sex=='男')&#123; document.write('帅哥'); &#125;else&#123; document.write('美女'); &#125; &#125;else&#123; document.write('未成年'); &#125; &#125;else&#123; document.write('hello others&lt;br/&gt;'); &#125;&#125;else&#123; document.write('bb&lt;br/&gt;');&#125; switch...case代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 // switch。。。case语句：执行效率比if else快高，但是if 可以比较范围，switch只能比较定值/* switch(exp)&#123; case 值1: 执行的代码段; break; case 值2: 执行的代码段; break; ... default: 执行的代码段; break; 严格类型比较 &#125; */ //简单示例var i = 4;switch (i) &#123; case 1: document.write("hello" + i); break; case 2: document.write("&lt;br/&gt;"); document.write("hello" + i); break; case 4: document.write("&lt;br/&gt;"); document.write("hello" + i); break;&#125;//注意breakvar j = 1;switch (j) &#123; case 1: document.write("&lt;hr&gt;"); document.write("a"); case 2: document.write("b"); default: document.write("这里是默认执行的代码，但是没有break"); case 3: document.write("&lt;br/&gt;" + "所以继续执行到 case 3："); document.write("c"); break; case 4: document.write("d");&#125;// switch多层语句示例var i = 66;switch (i) &#123; case 1: case 2: case 3: document.write('hello king'); break; case 4: case 5: case 6: document.write('hello maizi'); break; default: document.write('hello everybody'); break;&#125; (二)、循环语句 for循环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /* for(exp1;exp2;exp3)&#123; 循环体; &#125; exp1:无条件的执行第一个表达式 exp2:是判断是否能执行循环体的条件 exp3:做增量的操作 通过break结束for循环 continue:代表跳过当次循环，进入下次循环 */// 输出0-100for (var i = 0; i &lt;= 100; i++) &#123; document.write(i + '&lt;br/&gt;');&#125;document.write("&lt;hr/ color='red'/&gt;");// 输出1-100之间的奇数for (var i = 1; i &lt;= 100; i += 2) &#123; document.write(i + "&lt;br/&gt;");&#125;document.write("&lt;hr/&gt;");// 求1-100奇数的和var sum = 0;for (var i = 1; i &lt;= 100; i += 2) &#123; sum += i;&#125;document.write("&lt;h1&gt;" + sum + "&lt;/h1&gt;");// for循环练习：正序的九九乘法表document.write("&lt;table border='1' cellspacing='2'&gt;");for (var i = 1; i &lt;= 9; i++) &#123; document.write('&lt;tr&gt;'); for (var j = 1; j &lt;= i; j++) &#123; document.write('&lt;td&gt;' + j + 'X' + i + '=' + (i * j) + '&lt;/td&gt;'); &#125; document.write("&lt;/tr&gt;");&#125;document.write("&lt;/table&gt;");document.write("&lt;hr color='red'/&gt;");// 倒序的九九乘法表document.write("&lt;table border='1' cellspacing='2' bgcolor='gray'&gt;");for (var i = 9; i &gt; 0; i--) &#123; document.write("&lt;tr&gt;"); for (var j = 9; j &gt;= i; j--) &#123; document.write("&lt;td&gt;" + j + "X" + i + "=" + (i * j) + "&lt;/td&gt;"); &#125; document.write("&lt;/tr&gt;");&#125;document.write("&lt;/table&gt;"); while循环 1234567891011121314 /* while(exp)&#123; 循环体; &#125; do&#123; 循环体; &#125;while(exp); */// while循环练习var i = 0;while (i &lt;= 10) &#123; document.write("&lt;hr/&gt;" + i); i++;&#125; do...while循环 (三)、特殊循环控制 break 终止循环 12345678 // 通过break结束for循环for (var i = 1; i &gt;= 0; ++i) &#123; if (i &gt; 100) &#123; break; //结束for循环 &#125; document.write(i + '&lt;br/&gt;');&#125;document.write('&lt;hr color="red"/&gt;'); continue 跳过当次循环，进入下次循环 123456789// continue:代表跳过当次循环，进入下次循环for (var i = 1; i &lt;= 10; i++) &#123; if (i == 3) &#123; // break; continue; document.write('hello king'); &#125; document.write(i + '&lt;br/&gt;');&#125; 1234567891011121314151617//while循环使用break和continue var i = 0; while (i &lt;= 10) &#123; if (i == 3) &#123; // 注意continue后面的代码将不会执行，会出现死循环，添加i++ i++; //通过continue跳过当次循环 continue; &#125; document.write("&lt;br/&gt;" + i); if (i == 9) &#123; // break:可以结束while和do...while break; &#125; i++; &#125; (四)、案例练习 使用以上学习内容完成：公鸡5元一只，母鸡3元一只，小鸡3只一元，100元可以买100只鸡,问：公鸡，母鸡和小鸡各多少只？ 参考答案： 1234567891011121314151617181920212223 // 方法一：三层嵌套循环document.write("方法一：三个嵌套for循环");for (var i = 0; i &lt;= 20; i++) &#123; for (var j = 0; j &lt;= 33; j++) &#123; for (var k = 0; k &lt;= 300; k++) &#123; if (i * 5 + j * 3 + k / 3 == 100 &amp;&amp; k % 3 == 0 &amp;&amp; i + j + k == 100) &#123; document.write("&lt;hr color='yellow'/&gt;"); document.write("公鸡只数为：" + i + " " + "母鸡只数为：" + j + " " + "小鸡只数为：" + k); &#125; &#125; &#125;&#125;// 方法二：两种for循环嵌套及一个变量document.write("&lt;br/&gt;" + "方法二：两种for嵌套+一个变量");for (var i = 0; i &lt;= 20; i++) &#123; for (var j = 0; j &lt;= 33; j++) &#123; var z = 100 - i - j; if (i * 5 + j * 3 + z / 3 == 100 &amp;&amp; z % 3 == 0) &#123; document.write("&lt;hr color='red'/&gt;"); document.write("公鸡只数为：" + i + " " + "母鸡只数为：" + j + " " + "小鸡只数为：" + z); &#125; &#125;&#125; 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js基础】走进JavaScript]]></title>
    <url>%2F2017%2F09%2F11%2F2017-09-11-study-js1-walk-into-js%2F</url>
    <content type="text"><![CDATA[重新温故学习JavaScript基础知识点，记录自己的学习过程，学习JavaScript基础第一章节走进JavaScript基础。 走进JavaScript JavaScript简介 JavaScript是NetScape公司为Navigator浏览器开发的，是卸载HTML文件中的一种脚本语言，能实现网页内容的交互显示。当用户在客户端显示该网页时，浏览器就会执行JavaScript程序，用户通过交互的操作来改变网页的内容，来实现HTML语言无法实现的效果。 如何使用JavaScript 通过&lt;script&gt;&lt;/script&gt;中直接编写。 通过&lt;script src=&#39;目标文档的URL&#39;&gt;&lt;/script&gt;链接外部的Js文件。 作为某个元素的事件属性值或者是超链接的href属性值。 代码屏蔽 12345 &lt;script type='text/javascript'&gt;&lt;!-- Js代码;//--&gt;&lt;/script&gt; 如果浏览器不支持Js，可以使用&lt;noscript&gt;&lt;/noscript&gt;标签，显示noscript中的内容。 JavaScript的基本语法 JavaScript的执行顺序：按照在HTML文件中出现的顺序依次执行。注：如果需要在HTML文件执行函数或者全局变量，最好将其放在HTML的头部中。 大小写敏感：JavaScript严格区分大小写。 忽略空白符和换行符。注：JavaScript会忽略关键字、变量名、数字、函数名或其它各种元素之间的空格、制表符或换行符我们可以使用缩进、换行来使代码整齐，提高可读性。 语句分隔符：使用 ; 结束语句，可以把多个语句写在一行，最后一个语句的分号可以省略，但尽量不要省略，可以使用{}括成一个语句组，形成一个块block，通过 \ 对代码进行折行操作。 12 document.write(' hello\world'); 注释：单行注释 //，多行注释 /*注释内容*/ JavaScript的保留字： 通过 document.write() 向文档书写内容。 通过 console.log() 向控制台写入内容。 简单调试JavaScript中的错误：语法错误，通过控制台进行调试。逻辑错误，通过alert()进行调试。 参考文献： 麦子学院——King老师xmind文件]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我大三了]]></title>
    <url>%2F2017%2F09%2F10%2F2017-09-10-class-meeting%2F</url>
    <content type="text"><![CDATA[时光流逝再快，也夺不走我的记忆。 今日班会今晚在班级公众号写了推文，有一篇是关于班会的通知，大一当了一年的班长，上大二开始就召开一次班会发新书、收书费和学生证，最重要是换班委。那时，我只想辞去班长一职，不是说当班长累什么的，主要是大二想多花点时间和心思搞自己的事情，做喜欢的事。当班长一年确实学到了很多东西，锻炼了很多能力，交到了很多朋友。最主要是提高了自己的眼界和增加了丰富的经历，这些需要时间换来的，但是值得。但在那次班会，大部分同学还是希望我继续担任班长一职，但是我还是拒绝了，推说了半个钟才有人上来竞选班长，当然就他一人，没得选了，就是他啦！其他班委，真的是也没有人竞选，感觉这个班要瘫了，那时候感觉这个班好差劲，同学一个个事不关己，高高挂起的样子。我想这也是我当班长坚持不下去的一个理由。不管怎样，班级还是那个班级，我还是其中一员，我还是要维护它，一直坚持到现在。 大一初始回想起大一时候，当我们刚来大学的这几天，有学班带着我们班，那就是小赖师兄和栗子姐。小赖师兄大二，栗子姐大三了。那时，两个学班，带我们逛校园，讲解学校的东西，传授学校各种各样的事给我们听，还带我们搞活动，哈哈哈，那时候的我们，真的是如此的天真快乐，真好！特别是在我们系组织在西操搞活动班级比赛的时候，不为名次，只为快乐。现在我还记得，我们班输了一次比赛，我们要十几个同学上去鸭子步走起，哈哈哈，想想就觉得，那是我们样子好搞笑。再到我们军训了，学班还是一直在陪伴我们，即使是旷课也要来看看我们军训，关心我们，照顾我们，更多的是就想看看我们的样子和跟我们玩。想起自己从第一次鼓起勇气竞选军训时候的排长，到班长。好悬，也是好有挑战。当然，那时候我依然记得，竞选排长的时候，要是那时候没有舍友及身边几个同学的怂恿，也许我也不会坚定的鼓起勇气上讲台去吧。不过，那时候，有8个人还是10个人竞选这个排长，当然啦，这么多人竞选，还是败在我的演讲下了。果然，那时候一演讲，底气增加了不多，这也是奠定我竞选班长的一部分原因。竞选班长的时候，人很少，就两个人，我是势在必得的，另一个人估计是在逢场的，因为那时候感觉大家都支持我，不选我，还有谁！嘚瑟了一下，竞选其他班委的很多，可能大一吧，大家比较好奇和积极，也是为了证明自己的能力，我想是这样的。从当班长起，组织的班会，联谊，班游到一起参加的系运动会，班级篮球赛，班级辩论赛这些，我们一起经历过很多，很多。不管记忆是否美好，从现在看来都是不留遗憾的。至少大学，这些我们都有参加过。 大一活动大一上学期，我组织的第一次班会，我印象最深的是我们班委一起合唱动力火车的《当》，伟锋唱的《想你的夜》，真的很好听，毕竟他是有实力的文娱委员。到我们第一联谊，是跟英语2班，那时候班群一听说我们要联谊搞活动，大家都开心疯了，班群一直问一些很奇葩的问题，总感觉，大家都好期待，好想早点来。那次我很有印象，我们班委找对方班委都商谈过好几次活动形式要怎么搞，反正就是要搞好这次活动的意思，两个班级的人都很期待，压力好大的。那时候，两个班班委还组织合跳舞蹈，结果练习几次，因为对方班委觉得太难了，而放弃合跳。当然我们还是继续跳我们原定的舞蹈，我们班委四个男生，跳那个舞蹈，现在我感觉自己跳的就是尬舞，白练了那几天，联谊那天自己都跳错了，贼尴尬。不过，也没什么的，那晚联谊，总体还不错，来的人多啊，总共也有八十多个人吧！节目、游戏都挺好的，吃的、喝的都还行。结束后还一起去后门吃宵夜的。 时光流逝再快，也夺不走我的记忆。 未完待续不过有点可惜，当时写这篇文章的时候，没有一口气写完，因为已经到了深夜，自己也是很困了。所以，搁着到现在2018年2月23号才想起这篇文章，也许有点不美满，本想把大一到大三的经历及感慨都写完的。写完的话，应该会感动自己，哈哈哈，看来真的应该好好屡屡大学的往事了。]]></content>
      <categories>
        <category>我的大学</category>
      </categories>
      <tags>
        <tag>大三上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我爱你，不再见！]]></title>
    <url>%2F2017%2F09%2F04%2F2017-09-04-love-ending%2F</url>
    <content type="text"><![CDATA[人生就是这样，有些人走着走着，就散了；有些回忆想着想着，就淡了；有些事执着久了，就累了。 没想到，相爱的时间这么短，但还是抵不过异地后的分手，也许这就是我的宿命。但我真的是舍不得、放不下。结果我还是输给你了。对不起，曾经答应你的承诺，最终我还是做不到，感觉自己好无能，还没用，唯一能做好的就是默默的祝福你。 虽然我们的开始很随心，很奇怪，有点突然。但是彼此还是走在一起了，无怨无悔，开开心心在一起陪伴过彼此。从我们认识一个星期后，就开始互相坦白，表明心意，然后在一起了，还记得我们一起吃早餐、一起上课、每天一起逛校园。第一次牵你的手，心跳加速的我不敢想象，真的没有这么激动、幸福过，也许这就是爱的感觉、爱的味道。然后接着发生第一次接吻，那种感觉真的很美妙。有一种说不出来的美好，真的心里乐开花了，也许是第一次吧，感觉不一样。直到期末，我们的关系越来越好，越来越有感觉，就像是我的全世界是你，你的全世界是我一样。 还记得，那一天，我们去从化汽车站那边看电影，看你喜欢的《变形金刚5》，看电影的过程中，你一直牵着我的手，不离不弃，还时不时吻我的手，真的好幸福，我女票好可爱，好暖心，好想时光一直保留在这一刻，永远跟你在一起。之后，我们去逛街，去夹娃娃，哈哈哈，我花了5块钱，还好最后一个硬币加到了你喜欢的可乐白熊，你说你上次来就很喜欢这个可乐白熊了，一直超级想要。当我给你的那一刻，看到你高兴坏了，狠狠的亲了我一下，这种感觉，就像是就算得到了全世界也不如得到你的笑容美。要不是有人在，我真的很想跟你接吻了，这一刻，记在我心里，永久的珍藏，无法替代。 再跟你闺蜜一起商量完去广州游玩之后，终于有在一起相处的空间了。那三天两夜，虽然很累，真的很累。但是体会到一天到晚有你陪在身边不离不弃，陪你吃你想吃的，逛你喜欢的地方，看你喜欢的电影，买我们的情侣装。哈哈哈。累并超级快乐着。这几天的时光，是我最梦寐以求的快乐。 但是，暑假快来了，意味着我们第一次异地恋将要开始，想到我曾经给你的承诺： 结果呢。我承认我输了，输给时间了，输给我那初心了，没想到自己一个人默默的坚持真的很难，好难，好难受。 总之，跟你相处的两个多月里，不管是每天南方湖的闲聊还是广州游玩的那几天，我不得不承认，自己曾有过那么一刻，真的以为我们会一辈子在一起，感觉你会一直陪伴我，我可以放下自己所有的骄傲，迁就你的一切，可是，可是我真的想知道你到底发生了什么事触及到你灵魂让你做出如此大的改变，这变化的太快了，完全不是曾经的那个你了，我真的好后悔自己，如果那一天7月26号晚上，我没有说分开静几天，我想就不会发生这么多奇怪复杂的事了，那段时间，就是我们分开我感到最幸福的时光。我感觉你还是很多心里事没跟我说，就是有心结，一直压抑自己，封闭自己，不让我走进你的心扉。我相信我们相处了一段时间，虽然不长，但彼此都很开心呀。本来还是处于发展阶段的，可以相处的更好的。我以为是你爸妈的原因让你很烦，压力很大，我能理解，这个我们可以放慢时间，我可以等你，等你到27、8岁再来娶你，但是你跟我说，另一个原因，这个原因刚才听你亲口说出，内心是有多崩溃啊，你到底怎么啦，为什么，你让我不明不白的，像被耍猴一样，这种感受，我会得抑郁症的。不管我们能不能走到最后，我不会怪你，只是恨我自己。表白那晚之后，我做到了自己该做的事，我很多第一次都给你了，无怨无悔。因为你是我最意外的勇敢，也是我不得不放弃的纠缠。如果因为你说的原因分开的话，我真的真的不甘心，不甘心。如果你需要时间平复我们之间的感情，我可以等你，等你，等你回到我身边。 结果还是等到，你希望的彼此分开，看来你真的不爱我了，真心不爱我了，结果我还默默的守着你，还以为可以挽回点什么，结果什么都没有。 确实，说的很对。有些眼泪是自己的，痛了，没人能体会，有些累在心里，疼了，也只能自己煎熬。人生苦短，何必让自己活得这么累。过去的就让它逝去，别再回望，放不下只是自找烦恼，何必想太多，跟自己过不去，何必悲伤哭泣，伤了自己的身体。要知道，给自己划那么多的条条框框，最后也只能是为难了自己。生活不易，何必活得太累，太累伤身。还不如让心吹吹风，让脚步停一停。未来的风雨人生路，请你记得微笑着走，你笑的多了，烦恼才会少一些。 再见！我曾经最爱的那个你，如果我真的离开了你，并不是我有了新欢或者不爱了，是你的态度让我觉得可有可无，失望攒够了觉得坚持毫无意义了，我便已离开。。。本来就是明明是你先招惹我的，最后却是我深爱了、放不下你了。不过还是要真的谢谢你，遇到我，靠近我，接触我，理解我，温暖我，离开我。在这个过程已经足够让我心疼、伤心很久了！ 昨天晚上，看到你一副不缺我的样子和坚决的语气，我知道我没戏了，你让我怎么在你身边停留，不是我不主动了，是我发现我多余了，没有能力再爱你了，也许真的是心累了。 你离开了也许会变得更好，我不用担心怕失去你了。从此，我只是你的故人，不是你故事里的人。希望你过得很好，但别让我知道。祝你岁月无波澜，敬我余生不悲观。我爱你，不再见！ 你是我流年里不舍得温柔。从此以后，我爱的人，再无一分像你。 余生，各自安好。然后，再也不见。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[厉害咯！一个HR说：“为什么我们要招名校毕业生？”]]></title>
    <url>%2F2017%2F08%2F14%2F2017-08-14-hr-interviewer%2F</url>
    <content type="text"><![CDATA[为什么要招名校毕业生，竞争永远比想像的残酷。这个HR说得我有点无地自容！真是扎心了！ 写给自己的为什么有些企业招聘一定要211和985院校毕业的？今天看了一个节目短短不到5分钟的视频，最近微博点击量很高，就是一个资深HR和一个大学毕业生的问答节目，真的太现实了。看完你会明白：为什么大型公司喜欢招名校毕业生了！ 略有所感 之前看过知乎也有关于这个问题，回答这个问题的人也分析的很全面。也看过张鑫旭昨日发表文章对此的见解。看完后前端狗，内心无比复杂。万千言语，思绪横飞。但也不得不佩服现实。总得来说，名校和普校的差异就在于这几点： 一是：985/211毕业生平均来说工作的完整与完美程度比普校毕业生有显著的领先。 二是：985/211毕业生的平均学习能力要强不少，尤其是自学的能力。 三是：非985/211毕业生，基本没有竞争力和优势，可以说是千篇一律的大学批量生产的，有些甚至比非科班出身的程序员还差，但也排除有少数优秀的人才。 作为普校出生的我们，首先要认清自己，然后定位好自己，最后剩下的就是努力了。不要老想着时间还很多，当你回过头来看看自己走过的路，你就知道，自己有没有后悔。永远要相信“名校也有渣，普校亦出才。” 当你完全被打击了体无完肤，没话可说了，其实这个就是现实。讲真，真正能打击你的，是当你发现自己一无是处，还过着无忧无虑的生活的时候。 推荐阅读：作者：张鑫旭地址：http://www.zhangxinxu.com/life/2017/08/recruitment/知乎相关问题：https://www.zhihu.com/question/21686807]]></content>
      <categories>
        <category>面试招聘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[喜欢和爱的区别，究竟有多大？]]></title>
    <url>%2F2017%2F08%2F02%2F2017-08-02-like-and-love-dif%2F</url>
    <content type="text"><![CDATA[原来喜欢和爱，终是有区别的。 01你有没有喜欢，或者真正地爱过一个人？ 原来喜欢和爱，终是有区别的。写文章的我，经常会捕捉到一些微妙的感情，只有真正面对微妙时，我才深感语言的无能。 我们常常不能直接用言辞，进行最贴切、最完美、最淋漓尽致的表述，所谓辞不达意，大致如此。 所以我非常佩服钱钟书，喜欢《围城》，因为他的比喻和描写，常常可以把恍若如梦的微妙感觉精细地表达出来，恰如其分，精彩绝伦。 在我心里，最好艺术家不只可以表现大江大河气势磅礴，最重要的，他要抓住常人看不到的细微之处。细微，才是真正的精髓。 那么，回到问题：“喜欢和爱，有什么区别？” 这里面细微差别，在哪里？ 02你说，喜欢是想靠近，爱是离不开。 你说，喜欢是浅浅的爱，爱是深深的喜欢。 你说，喜欢是这姑娘不错，而爱，是这姑娘不错，我一定照顾她一辈子。 你还记得韩寒电影里的台词：“喜欢就是放肆，但爱是克制！” 我还记得有一个特别好的比喻句：喜欢是荡秋千,可以自得其乐,不需别人的回应;爱是跷跷板,需要一个人坐在对面与你互动,贴近你内心的感觉。 原来喜欢可以是一个人的事，而谈到爱时，你已经不再孤单。 喜欢是心与心的碰撞，爱是心与心的融合。 喜欢是新鲜感，是一种感觉；爱是归属感，是一种责任。 喜欢是你能让我开心，爱是你开心我就开心。 喜欢是我希望你对我好，爱是我希望能对你好。 喜欢是没你也可，爱是没你不可。 喜欢是乍见之欢，爱是久处不厌。 …… 03你还可以更细致。 喜欢就像白水，淡淡的，阳光可以透过。喜欢是相爱的基础和起步，沒有太多強制或壓迫的成分。愛則如咖啡，在白水的基礎上加上了咖啡粉。愛，是把他融入自己的生活，融入自己的骨血，把他看成是自己不可或缺的一部分。就像結婚現場，新郎新娘永遠不會說我喜歡你，而是我愛你。 你手里拿着一块巧克力，喜欢，是给你吃，而爱，是和你一起吃。 你说，喜欢可以哭着辜负，爱愿意笑着别离。 你好像是走错片场了，喜欢，是汤普森拿了60分；爱，是威少连续六场三双。 喜欢是没谈恋爱前，爱是已经恋爱后。 喜欢是一种心情，爱是一种感情。 喜欢只是当下，爱会包含未来。 喜欢是喜欢你的所有闪光点，而爱是更愿意包容你的不足。 你说你们会吵架，而喜欢是争吵，爱是傻笑。 也许，喜欢像风铃，风吹时，清脆悦耳；爱像手表，全天候，旋转不停。 04其实我们现在谈喜欢和爱，都是站在河对面，遥遥观望。当然，也只有这种抛开利害心的观望，才能看到其中的美。 而我始终坚信，所有美的微妙，都可以引起心灵深处持久的颤动。 所以我喜欢沈从文，他笔下的女性是可爱的，因为她们流露着人心所向往所喜欢的天真、温柔、纯洁、美。 我也喜欢汪曾祺的平淡和柔情，他用最细腻的心灵体味着生活，又用传神的笔墨展现出来，让我们享受，让我们感动。 其实谈喜欢和爱，最终谈的是我们的心。 真的，我们的生活太多过于粗线条了，偶尔的细腻，是对生命的矫正。 05我知道，喜欢和爱，都会让我们的生活充满阳光。 我真的，就想看你一眼。喜欢，是看一眼就好；爱，是看一眼看一眼再看一眼。 分享了这么多，最后，请让我分享爱情里最让我感动的八个字。 执子之手，与子偕老。 参考文献： 作者：怀左同学 链接：http://www.jianshu.com/p/2efe1ab462a7 來源：简书]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github是怎样的一个存在？]]></title>
    <url>%2F2017%2F08%2F02%2F2017-08-02-how-github-exist%2F</url>
    <content type="text"><![CDATA[以下，就这三个问题分别展开： 一个活跃的 GitHub 账号有什么用？你真的需要一个活跃的 GitHub 账号吗？如何经营一个活跃的 GitHub 账号？ 一个活跃的 GitHub 账号有什么用？首先，GitHub 会给你更多被看见的机会。 收到过很多创业公司的邮件都说是通过 GitHub 看到我的，一开始我还有点小激动~ 其次，一个活跃的 GitHub 账号会给你加分不少。曾经听朋友转述过一个大神的话：“哇，她 GitHub 竟然比我粉丝还多，我得去了解了解~”如果这个人是面试官就更好了 (‘▽’)♪ 第三，GitHub 让你更有动力做开源项目。 我的目标是三年内做出一个 200 star 的项目…好吧，乱想而已… 但确实写的代码会被别人看到被点赞以后，就更有动力时常更新了，还有那个绿点点啊！满满的多有动力！反作用是…有时候一天提交太多了，整个变浅了啊！不开心不开心 ≥﹏≤ 你真的需要一个活跃的 GitHub 账号吗？我觉得没有必要每个人都如此。 首先，我之所以在 GitHub 上这么活跃，最主要的原因是因为我性格里的外向型。这里的外向，是说动力、能量的来源来自于别人的肯定和认同；相反，内向型的人来自对自我的肯定和认同。（详见 MBTI，我是 ESFJ）ESFJ 又喜欢帮助别人（其实真正喜欢的是帮助别人后别人的夸奖吧+_+），所以就连写程序这种很寂寞的事，都会被我玩成带有社交属性的事。相反，如果你根本不在乎别人的评价，你在 GitHub 上写了代码，估计也就这样放在那里，不会有人看到，偶尔有人搜到，你又没用心写 README（因为你根本不在乎啊），别人下载下来试了试完全不知道怎么用，也就放弃了。这跟你不开源也没什么区别。而且让一个内向型的人去做迎合别人喜好的事也挺辛苦的，最后连对编程仅剩的那些爱好都消磨完了，辛苦经营出来的 GitHub 账号又根本没人来点赞关注，这就是事倍功半。 其次,就是我脑洞比较大，经常有些 idea，所以就会去做出来。比如学易经变卦的时候，我想知道每一爻的变化会让卦象从什么变成什么，所以做了 变卦·易经64卦 ；看到 Gmail 附件折角的效果，想用 CSS 实现，做成一个 jQuery 的插件，所以有了 jCorner ；希望在豆瓣网站上看到可供下载的 ReadFree 上的电子书，所以做了 Chrome 插件 豆瓣 ReadFree 传送门 ；经常在网页里看国学的书想查汉典，所以做了Chrome 插件 汉典划词查询 ；等等……相反，如果你本身并不是一个有很多想法的人，你就会觉得有这么多创意其实要比实现更困难，最后只能是自我否定地觉得为什么别人这么厉害，我什么都没想法。其实不是谁厉害，只是每个人的性格不同所以需要采用不同的激励方法。了解你自己，用你的办法激励自己，让自己变得更优秀。你看我一年 commit 633 次，就算平均每个 commit 半小时的工作量（通常应该不止，我随便估计的），那也有 316 个小时，平均每天将近一个小时了。如果你的兴趣不在此，与其每天痛苦一个小时，不如把时间花在别的上面，比如对底层知识感兴趣的就去学底层，对设计感兴趣的就去学设计，一年下来你虽然不会有一个漂亮的 GitHub 账号，但是面试的时候这些一样会是加分项。不要今天看着人家 GitHub 厉害就去搞这个，明天看着人家知乎大神又去搞那个。每个人的时间都是有限的，机会成本都很高，我们都知道蛮力通常是程序员最后的选择，要学会剪枝才能事半功倍。 综上如果你的性格确实比较适合做一些开源的东西，在和别人分享的同时，让自己的 GitHub 变得更好看，那么当然这是一个面试加分项。但是，如果你并不能享受其中的乐趣，只是把这个作为一项需要苦苦经营的东西，那么我觉得大可不必花时间在这上面。 最后，如果你真的想搞个漂亮的 GitHub 账号，应该怎么做呢？首先，你得有有用或有意思的项目。GitHub 很明显是基于项目的，如果你的项目本身很无用又很无趣，那么推广是很困难的。这倒也不是说完全没法推广，只是……一个连好的项目 idea 都想不出的人，又怎么想得出推广的办法？项目的来源很多了，可以是贡献到现有的比较有名的项目，或者你自己生活中碰到一个需求需要解决又突然来了灵感。作为入门者，直接参与到现有的项目并不容易，因为首先你得对别人的项目有充分的了解，所以还是后者更容易着手一点。如果你实在想不出做什么，其实也别太着急，下次当你什么东西用的不爽的时候，及时记下问题即可，再过阵子说不定就想到解决方法了。 其次，你得推广。好像程序员写一两个有用或有意思的项目也并没有太难，只是很多人把“开源”理解为写完的代码放在那边，“开”着“源”，你的任务就算完成了。其实这只是一个开始。为什么要让别人看到你的代码呢？为什么要特意推广呢？为什么酒香还怕巷子深呢？为什么不能让别人要用的时候再搜到你的代码呢？因为是你说你要一个漂亮的 GitHub 账号啊！好，我直接说怎么推广。 能做成英文的东西，就做成英文的（有时间有精力就做双语行了吧），这样你就能推广到国内外的很多平台了，当然，造福的人更多没什么坏处嘛！ 如果是给别人用的库（而不是展示类的作品），好好写 README 和文档之类的，这会让你看上去很专业（即使你不是真的很专业）。 做一个项目主页，并添加链接到 GitHub 项目。（有的时候看一堆介绍根本没感觉，看到一个很高大上的项目主页，直接就想点赞了有木有） 如果你不是玻璃心，那么 reddit: the front page of the internet 通常是能够带来最多流量的一个平台。上面的人都会给你提很多很尖锐的意见，所以一般如果不是特别拿得出手的东西，我不会轻易往上发，太打击了……相反，Google Plus 上通常都是 +1 和说好听的话的人，粉丝不多的话可以发到相应的 community。但看到的人数和 reddit 相比就差远啦，自己掂量你的玻璃心吧~ 分享到你能想到的所有相关平台吧，包括 SNS，因为你的朋友中可能也有很多程序员或者用户。 在知乎多回答回答问题，像我这样贴链接：Ovilia (Wenli Zhang) · GitHub 参考文献： 作者：羡辙 链接：https://www.zhihu.com/question/28976652/answer/42793942 来源：知乎]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我要活得这么累]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-why-tired%2F</url>
    <content type="text"><![CDATA[在一个美好的年纪，却没有一个美好的生活，每天都是过得一个样：白天搬砖，晚上读书、写作+锻炼，生活平平淡淡，没有说过的怎么样精彩，但是感觉每晚睡觉前都感觉很累很充实。感觉自己没有浪费自己的时光，但这样真的好吗？ 如果生活辜负了你，你不要辜负你自己。是的，我们就应该活出理想中的自己，做自己心目中的英雄，就算全世界，没人认可你，也要坚持自己，不为对错，只为自己，因为我就是我，我有我的风格。 在坚持的路上很难，真的很难。说都想活得轻松、潇洒、自在。但那是一个咸鱼般的生活。人生不应该得过且过，苟且偷生。一生碌碌无为，那不是当今之世的观念。那是自我能力的否定。我要活出我想要的自己，就算再累，我无所畏惧。我要让世界变成我想要的样子。加油，哦！]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有时候，不疯狂一下，都不知道自己年轻过]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-sometimes-crazy%2F</url>
    <content type="text"><![CDATA[对于一个经常宅宿舍的程序员来说，出去跟同学一起浪是稀有的事。在这岁月静好，无忧无虑的时代，一切都是那么美好，一切都是那么令人向往。在这五一假日，相约几个同学，来一场说就走的游玩，是多么的惬意自在、轻松潇洒。 以前总喜欢一个人，习惯了一个人，孤独寂寞的一个人。就因为这样，感觉自己年纪轻轻就活的很老气，没有一点朝气，没有那一点年轻人一样的热血沸腾。可能习惯久了吧，自己变得都不认识自己了。前天我们团队小组去参加穗港IT的决赛答辩，全称很淡定，不紧张、不激动、不畏惧，更多的是从容淡定，可能习惯了自己的性格。虽然结果不尽人意，但是经过这次比赛，让我感受到团队的力量和技术创新的重要性。有比较才有突出，才有差距。是的，在当今的时代里，一切都变化太快，我总记得我高一语文老师说的一句话：“当今之世，物竞天择，适者生存。不想被淘汰就好好努力。”也许这就是社会，这就是一个生存、发展的竞争。所以，无论结果如何，每个奋斗过的青春都是无怨无悔的。因为年轻，我们无所畏惧，因为年轻，我们敢于奋斗，因为年轻，我们就是这么疯狂。 感谢这两天遇到的、相见的小学同学和高中同学，遇到了你们，看到你们欣喜的笑脸，此刻我才发现，我还年轻，我还是跟你们一样，天真无邪，活泼好动，喜欢开玩笑，喜欢逗比。看来只有同学久后相见，才有别一番滋味。一起回忆往事，一起聊聊心事，一起谈谈青春理想。这一切都是那么的清新、美好。然后一起去逛街，去吃美食，去看风景。虽然一天下来很累，但是值得，回忆起来好幸福，这一切是多么令人怀念。有你们在，真好！ 愿未来的日子里，你们要过得好。一切不如意的事都随风而去吧，来一场有多疯狂就多疯狂的游玩。这就是青春，我们还年轻。]]></content>
      <categories>
        <category>我的大学</category>
      </categories>
      <tags>
        <tag>大二下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有时候，谁都会很烦...]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-sometime-annoyance%2F</url>
    <content type="text"><![CDATA[有时候，每个人都会很烦恼。 有时候，会很烦。生活的烦恼无处不在，有时候，很无助，很绝望。主要靠自己看开一点，放下一些。生活说的简单，过得却很复杂。不管生活过得怎么样。还自己一个微笑，睡醒又是一个美好的一天。也许我们的人生恰是蒲公英，看是自由，其实是身不由己。 有时候，会很烦。有时候，心情会很差。要不是自己什么都不懂，要不是自己做这个也错，做那个也错，然而别人却可以随随便便做好。有时候，会很无奈，努力了却没得到自己想要的，却付出了沉重的代价。怪自己不是享受的命，只好劳苦。难道万般皆是命，半点不由人吗？ 有时候，会很不甘心。有时候，会很累，很累。什么都要自己独立承担，说什么理想，谈什么梦想，除了坚强，还有什么选择吗？有时候，会很想哭。谁都有受伤的时候，委屈要咽下去，哭也只能偷偷的。有时候，别无选择。过不去的，只是自己，生活还是要继续的。有时候，会很迷茫。不知道自己要做什么，不知道自己能做什么，不知道自己活着为了什么，不知道自己为什么而活，就算想努力一把，也会觉得先天不足，后天无力。有时候，真的只能自己接受。烦了，靠自己想通。累了，放空自己。哭了，擦干自己。当你强颜欢笑，成了一种习惯的时候，那么烦，也成了一种习惯。 假如生活辜负了你，请你不要辜负你自己。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱，永不止息——致自己]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-love-myself%2F</url>
    <content type="text"><![CDATA[爱是恒久忍耐，又是恩慈；爱是不妒忌，爱是不自夸，不张狂，不做害羞的事，不求自己的益处，不轻易发怒，不计算人的恶，不喜欢不义，只喜欢真理；凡是包容，凡是相信，凡是盼望，凡是忍耐。（摘取《新约全书》） 挺有感触的这几句话，第一次看到这几句话时，觉得颇有懵懂，这也许就是婚礼证词吧。等到第二次看到这几句话时，回想到的竟是人生。虽然觉得自已在一个花季少年的年龄谈人生，应该没什么资格吧！但生活就是这样，经历了迷茫，走过了悲伤，伤痕累累的时候，但又不能停下。有人说生活是自己选择的，人要活得精彩。又有人说谁的青春没有奋斗过，煎熬过。那又为什么去坚持？ 很喜欢的一句名言：“年轻的时候就能找到自己喜欢并且干一辈子的事情是多么幸福多么令人羡慕啊”。确实，当今世界，一切都变化太快了，能保持初心不改的人能有几个，想想当年我们说好的约定，想想当年我们说好的要一起创业，想想当年我们要实现的抱负。改变的不是我们，是时间。不管别人怎么想，不管世间如何变化，我们都要用于坚持自我，勤奋自勉。希望在以后的某一刻回忆起来可以让自己泪流满面，我想这才是奋斗过得青春。 爱自己，爱别人，感激自己，感谢身边陪伴你的人，生活是要过的美好，但别忘了人生需要奔跑。唯愿一路清风都在，且行且珍惜！]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的JS/jQuery技术和技巧]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-frequent-js-jquery%2F</url>
    <content type="text"><![CDATA[常用的这些方法快速提高你的编程速率 转载一篇博客原文链接为：http://blog.csdn.net/zollty/article/details/53944071 1. 获取指定id的某个属性的值 例如，获取id=myForm的表单的action属性的值：document.getElementById(&quot;myForm&quot;).action 也可以设置它的值：document.getElementById(&quot;myForm&quot;).action = &quot;/cqrd/aa.action&quot; 获取指定name的某个属性的值，例如：document.myForm.action 2. 通过js去提交表单 document.getElementById(&quot;myForm&quot;).submit(); ，即使myForm这个表单中没有 &lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;，也可以用此方法去提交表单。 3. 跳转document.location.href = &quot;${ctx}/emp/delEmp.action?id=&quot;+id ;，跳转实例：{根据所选的option的值执行跳转}onchange=&quot;location.href=this.options[this.selectedIndex].value&quot;&gt; 4. 正则表达式 验证日期格式 2014-11-30 如下： 1234567function validDate(str) &#123; var reg = new RegExp(&quot;^201[0-9]-((0[1-9])|10|11|12])-((0[1-9])|(1[0-9])|(2[0-9])|30|31)$&quot;); return reg.test(str);&#125; 正则表达式特殊符号转义，例如点、星号，反斜杠转义为 .和* 5. 判断字符串长度(中文算3个字符)方法如下：`var len = $(&quot;#taskName&quot;).val().replace(/[^\x00-\xff]/g,&quot;***&quot;).length;` 6. URL跳转 12&lt;body onload=&quot;[JavaScript](http://lib.csdn.net/base/javascript):document.location.href=&apos;$&#123;ctx&#125;/dept/query.do&apos;&quot;&gt;&lt;/body&gt; 7. JS字符串替换 replace(expr, target)，第一个为正则表达式，所以replace(&quot;a&quot;,&quot;b&quot;)只会替换第一个（匹配一次）。 要全部替换，用：（匹配全部），replace(new RegExp(/(a)/g),&#39;b&#39;) 注意不要在(a)上加单、双引号。 8. 获取多选按钮的值 12345678910111213141516$(&quot;input[name=&apos;RA_CHO&apos;]&quot;).click(function()&#123; var RA_CHO_value = &apos;&apos;; $(&quot;input[name=&apos;RA_CHO&apos;]:checked&quot;).each(function()&#123; RA_CHO_value += $(this).val() + &quot;，&quot;; &#125;); if(RA_CHO_value.length&gt;0)&#123; RA_CHO_value = RA_CHO_value.substring(0, RA_CHO_value.length-1); &#125; alert(RA_CHO_value); &#125;); 9. jQuery设置标签为隐藏或显示动画（注意不是style） 12345$(this).hide(&quot;fast&quot;);$(this).show(&quot;fast&quot;);// jquery判断标签是否为隐藏或显示状态if($(&quot;#a&quot;).is(&quot;:visible&quot;))if($(&quot;#a&quot;).is(&quot;:hidden&quot;)) 10. jQuey AJAX模板 12345678910111213141516$.ajax(&#123; url: &apos;/ax/text&apos;, type: &apos;POST&apos;, data: &#123; eftDateBegin: $(&quot;#eftDateBegin&quot;).val(), eftDateEnd: $(&quot;#eftDateEnd&quot;).val() &#125;, dataType: &apos;json&apos;, timeout: 1000, success: function(data) &#123; $(&quot;input#showTime&quot;).val(data[0].demoData); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; alert(); &#125;&#125;); 11. 常用JS函数 12345678910111213141516171819202122232425262728//判断是否为空 function isNull(value) &#123; if ((value == &quot;&quot;) || trim(value).length == 0) return true; return false; &#125; //是否以中文开头 function isChinese(str) &#123; if (trim(str) == &quot;&quot;) &#123; return false; &#125; if (str.charCodeAt(0) &lt; 0x4e00 || str.charCodeAt(0) &gt; 0x9fa5) &#123; return false; &#125; else &#123; return true; &#125; &#125; //验证字符串为数字 function checkNum(tt, viewobj) &#123; var reg = /\D/; /*数字字符*/ if (reg.test(tt)) &#123; if (viewobj &amp;&amp; viewobj.tagName.toUpperCase() == &apos;SPAN&apos;) &#123; viewobj.className = &apos;alertcolor&apos;; viewobj.innerHTML = &apos;请输入数字&apos;; &#125; return false; &#125; return true; &#125; 12. 异步加载js 12345678910111213141516//该匿名函数用于异步加载js(function() &#123; function async_load() &#123; var s = document.createElement(&apos;script&apos;); s.type = &apos;text/javascript&apos;; s.async = true; s.src = &apos;js/config.js&apos;; var x = document.getElementsByTagName(&apos;script&apos;)[0]; x.parentNode.insertBefore(s, x); &#125; if (window.attachEvent) &#123; window.attachEvent(&apos;onload&apos;, async_load); &#125; else &#123; window.addEventListener(&apos;load&apos;, async_load, false); &#125;&#125;)(); 13. JSON操作 1、字符串转换成JSON对象：用jQuery：jQuery.parseJSON( data ); 2、JSON对象转字符串用json2.js，text = JSON.stringify( jsonObj ); 14. IE（&lt;10）下面无法往table里面插入 innerHTML 例如： 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;demo&quot;&gt;&lt;/table&gt;&lt;P id=&quot;PP&quot;&gt;&lt;/P&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;xxxxxxxxxx&quot;);document.getElementById(&quot;PP&quot;).innerHTML= &quot;ZZZZZZZZZZZZZZZZZZZZZ&quot;;document.getElementById(&apos;demo&apos;).innerHTML= &quot;&lt;tr&gt;&lt;td&gt;0000000000000000000&lt;/td&gt;&lt;/tr&gt;&quot;;$(&quot;#demo&quot;).html(&quot;&lt;tr&gt;&lt;td&gt;0000000000000000000&lt;/td&gt;&lt;/tr&gt;&quot;);alert(&quot;ddddddddddd&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; table中是无法插入的innerHTML的。 15. JS函数调用时，传字符串时一定要加上’’(单引号)例如：`download(&apos;${task.taskNo}&apos;)`，如果不加&apos;&apos;，则download函数无法执行，如果是数字时，就无需加&apos;&apos;(单引号)。 16. 跨域访问 出 于安全的考虑，Web 浏览器从很早之前就定下“同域安全策略”的标准，默认情况下同一域名下的页面只能向同域（包括 CNAME 域名、端口）下的 URL 发送所有类型的 HTTP 请求。而向不同域的地址发送非 GET 请求时，默认情况下只能返回同域安全策略错误。 对此，在发起上传或下载请求的时候，七牛的服务会返回相应的支持跨域的 Header: 上传(upload.qiniu.com) 123Access-Control-Allow-Headers: X-File-Name, X-File-Type, X-File-SizeAccess-Control-Allow-Methods: OPTIONS, HEAD, POSTAccess-Control-Allow-Origin: 下载(.qiniudn.com) Access-Control-Allow-Origin: 注意：本文来自转载，如有侵权，请联系作者删除]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP：简单的学习笔记]]></title>
    <url>%2F2017%2F07%2F29%2F2017-07-29-http-simply-study%2F</url>
    <content type="text"><![CDATA[作为一个开发人员，如果您经常跟客户端、服务器打交道，肯定要懂点HTTP协议内容，对于开发调试至关重要。 HTTP协议 （HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。它是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 简单介绍一下内容： HTTP的工作原理 HTTP的消息结构 HTTP的请求方式 HTTP的响应信息 HTTP的状态码类 HTTP Content-type 1. HTTP的工作原理 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 HTTP协议通信流程图： 需要注意的是： HTTP无连接状态：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP媒体独立状态：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 2. HTTP的消息结构 HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的，和通过接收客户端的请求并向客户端发送HTTP响应数据。HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端发送请求结构图： 服务器响应消息图： 3. HTTP的请求方式常用的请求方式列表： 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 4. HTTP的响应信息参数列表： 应答头 说明 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。 Content-Length 表示内容长度。 Content-Type 表示后面的文档属于什么MIME类型。 Date 当前的GMT时间。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。 Location 表示客户应当到哪里去提取文档。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？ 5. HTTP的状态码类这是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 具体分类表： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 6. HTTP Content-type Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 Markdown 语法格式来编写文章]]></title>
    <url>%2F2017%2F07%2F28%2F2017-07-28-beautiful-markdown%2F</url>
    <content type="text"><![CDATA[Markdown 编写文章攻略注：本教程需要一点对markdown语法格式的了解，什么都不知道的，请直接看献给写作者的 Markdown 新手指南的参考资料，再来看本文，会更好的去学习。 基本排版格式(一) 目录编辑 导航目录链接制作,一般使用二级、三级标题格式(需要解析) 第一种方式获取标题： 12* TOC&#123;:toc&#125; 小标题无序目录(注意空格) 12* 目录一* 目录二 小标题有序目录(注意空格) 121. 目录一2. 目录二 锚点链接(注意英文字符) 12[目录](#目录)[Fork 指南](#fork-指南) (二) 链接表示 基本插入链接表示： 网址链接：[猿来独往](https://super456.github.io) 本地图片链接(最好使用图床网站获取图片url)： ![](/images/wiki/eclipse-need-java6.png) 待定链接：[这个链接跳转不了](#) 统一的的链接跳转方式(为了排版好看一点)： 1234567参考：[mpv keybindings][0]参考：[OPTIONS][1]参考：[MPV使用小记][2][0]: https://github.com/mpv-player/mpv/blob/master/etc/input.conf[1]: https://github.com/mpv-player/mpv/blob/master/DOCS/man/options.rst[2]: https://segmentfault.com/a/1190000004533079 快捷插入网址链接表示形式：&lt;http://example.com&gt; (三) 表格排版 表格排版参考(注意空行) 12345| 功能 | 快捷键 for win | 快捷键 for mac ||:---------|:---------------|:---------------|| Project | M-1 | Cmd-1 || Terminal | M-F12 | M-F12 || Editor | Esc | Esc | 注意：:--------- 表示文字居左显示，:---------: 表示文字居中显示，---------: 表示文字居右显示。 (四) 文字处理 分割线 第一种方式：----- 第二种方式：*** 效果展示： 删除线：~~删除线~~ ，效果展示：删除线 斜体：*斜体* ，效果展示：斜体 表情插入(需要解析) 123:camel::blush::smile: 表情语法专属官网 脚注提醒(需要解析) This is a text with footnote[^1]. [^1]: Here is the footnote 1 definition. 键盘键显示(需要解析)： &lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;S&lt;/kbd&gt; 效果展示：Alt + Shift + S 电子邮箱输入：&lt;1111111111@qq.com&gt; ，效果展示：&#49;&#49;&#49;&#49;&#49;&#49;&#x31;&#x31;&#49;&#49;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d; 代办列表: 表示列表是否勾选状态 12- [ ] 不勾选- [x] 勾选 上下标(需要解析) \^表示上标, _表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。 例如： x^{y^z}=(1+{\rm e}^x)^{-2xy^w} ，效果展示： x^{y^z}=(1+{\rm e}^x)^{-2xy^w} 添加下划线： php\_gd2.dll ，效果展示： php_gd2.dll 笔记本和标签(部分编辑器支持)： @(示例笔记本)[标签1|标签2|标签3] 。 (五) 引用 区块引用可以嵌套，只要根据层次加上不同数量的 &gt; ： 12345&gt; 这是第一级引用。&gt;&gt; &gt; 这是第二级引用。&gt;&gt; 现在回到第一级引用。 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 123456* Coding.net有以下主要功能: &gt; 代码托管平台 &gt; 在线运行环境 &gt; 代码质量监控 &gt; 项目管理平台 (六) 简单的图形 代码图形 1234567891011121314151617+-------------+ +-------------+| | ... | |+-------------+ +-------------+| | | |+-------------+ +-------------+| format str1 | &lt;-- esp | format str2 | &lt;-- esp+-------------+ +-------------+| double low | | int |+-------------+ +-------------+| double high | | double high |+-------------+ main stack frame +-------------+| ... | | ... |+-------------+ +-------------+| | | |+-------------+ +-------------+| (%ebp) | &lt;-- ebp | (%ebp) | &lt;-- ebp+-------------+ +-------------+ 构建文件夹图形 1234567891011121314app/src/main├─assets├─java│ ├─android│ │ └─content│ │ └─pm│ └─org│ └─mazhuang│ └─easycleaner└─res ├─drawable ├─layout ├─menu ... (七) 代码语法 单行代码语法： 两个`，中间输入内容 多行代码语法(注意前后空行)：第一行输入三个 ` 然后最后一行再输入三个 简单的语法高亮 1git checkout -b test 5234ab 1print 'Hello, World!' 代码高亮语言标识符支持的语法 支持的有javascript（js）、cpp、makefile、vbnet、xml、c、java、cl、vim、sh、yaml、markdown(显示原语法格式)、html、vb、python等等 参考文献 (1)、中文文案排版指北（简体中文版） (2)、献给写作者的 Markdown 新手指南 (3)、Markdown语法介绍 (4)、Markdown 语法说明 (简体中文版) (5)、马克飞象-在线编辑器]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习惯成就高效能]]></title>
    <url>%2F2017%2F07%2F28%2F2017-07-28-sevenhabits%2F</url>
    <content type="text"><![CDATA[分享一篇文章：对高效能人士的七个习惯的学习笔记。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2014/10/28/sevenhabits/ 首先需要说明的是，我并不相信成功有什么方法论，不过生活中很多的事情确是有套路可以遵循借鉴的，正如公元前两三百年的时候，亚里士多德就说过的话： 人的行为总是一再重复，因此卓越不是单一的举动，而是习惯。 这应该就是之前我引用到说说而被某人说矫情的一句话的源头——优秀是一种习惯。 两个自身条件、机遇等等差不多的人，随着时间的流逝逐渐拉开差距，也许只是其中一个有意识地让自己形成了一些良好的习惯与套路，而另一个迷迷糊糊地就将自己也不知道为什么这么做、是对是错的动作坚持了很多年。 如下内容是根据前几天参加的培训总结的笔记，是我认为比较实用的套路和惯例，迄今为止我尚未拜读过史蒂芬.柯维的大作《高效能人士的七个习惯》。 目录 TOC{:toc} 有鹅才能有金蛋据说一篇有趣的文章都应该以讲故事开头： 一天，一个很穷的农夫在鹅窝里发现了一个金光闪闪的蛋，更让他喜出望外的是这个蛋是纯金的。这之后，农夫每天都可以从鹅窝里拿到一个金蛋。然而，当他日益富有的时候，他也越来越贪婪，以至于没有耐心等待每天只有一个金蛋，他想一次拿到鹅身体里的所有金子，于是他杀了这只鹅，但结果却是什么都没得到。 ——伊索寓言《鹅和金蛋》 这听起来真是一个悲伤的故事啊！但是坑爹的他已经凭白无故拿到好多金蛋可以幸福地生活下半辈子了鹅没了也就没了为毛我连彩票都没中过十块以上的所以人生还是不公平的啊！ 好吧寓言应该不是告诉我这样去想问题的，还是听老师的话，这样来理解吧：杀鹅取卵的做法当然不可取，但是想想这样的事情自己却也没少干，随意举几个： 熬夜，少运动——慢性扼杀身体这只鹅 晚上一不留神就熬到夜深，虽然一周打一两次羽毛球但是相对整天地坐着还是太不够…… 偷懒，少学习——慢性扼杀智慧这只鹅 大多数时候还是功利地学习，遇到什么问题只是针对地去解决，事后主动地寻求系统地补充相关知识的时候容易偷懒进度慢…… 死宅，少沟通——慢性扼杀感情这只鹅 跟好多人一样，朋友见面好不容易能交流的时光被消磨在了手机屏幕上…… …… 想要源源不断地收获金蛋，那就要用心去养好自己的几只鹅，让它们心情愉悦精力充沛，远离死亡的威胁。据说这是一份相对合理的每天养身体、智慧和感情这三只鹅的一天二十四小时时间分配图，可以以此为基础根据自己实际情况稍作修改做一份适合自己的作息计划： 反射弧里加一环一般来讲，我们感觉遇到困难的处境后是这样的： 但是实际上发生的过程是这样的： 这就是为何同一件事情，不同的人会有不同的感受和回应方式的秘密。觉察到中间这一环，就能自由选择以什么样的心情和方式来回应。 解决问题三部曲 定义问题 发现问题 有什么样的现象? 定义问题 我想要什么，如何 XXX？ 不能仅停留在发现问题的层面然后就去想对策，让自己用「如何XXX」的句式找出真正的诉求。 分析问题 遇到问题画个圈，弄明白哪些因素是关注就可以的，哪些因素是自己真正能影响的。 关注圈 包括所有关切和担心的因素。比如可能有别人的理解能力、性格等等。 影响圈 包括所有可以影响的因素。比如可能有别人的意愿、自己的沟通技能技巧、第三方的力量和证明材料等等。 主动积极的人会努力扩大影响圈，而消极的人则可能会在困难面前畏缩而导致影响圈里的一些东西被关注圈吞噬。 解决问题 选择影响圈里的项目——计划和实践——总结、确认、重复 时间管理的建议 不能管理时间，便什么都不能管理。 ——彼德.德鲁克 据说努力让手上的事务主要集中在II区域会让你成为一个下面这样的神人： 有远见、有理想 平衡、纪律性强、自制 少有危机、身体健康 工作生活和谐、人际关系良好 良性的团队发展 三个实用小惯例 事情已经如此了，我（们）能做些什么呢？ 问题本身不是问题，如何解决才是问题。 与别人沟通时遇到不同的看法，记得用「好，很好，说说看！」和「好，很好，还有吗？」，多问、多听、少说。 追求卓越模式图好吧扯了半天貌似跟原书关系不大，说的都是些野路子，那么下面干货来了，据说这张图是《高效能人士的七个习惯》这本书的核心。 主要理念： 成长分三个层次：依赖型、独立型和互赖型。依赖心重的人靠别人来完成愿望，独立自主的人自己打天下，互赖的人集思广益以达成功。 依赖型的人能通过主动积极、以终为始、要事第一三个习惯逐渐成长为独立型的人，独立型的人能通过双赢思维、知彼解己、集思广益三个习惯逐渐成长为互赖型的人，不断更新的习惯则是要求能将前面说的六个习惯不断运用，常用常新。 个人成功的要点是自我掌控和自律，公众成功的核心是深入、持久、高效的人际关系。 发现问题 有什么样的现象？]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情绪管理的建议]]></title>
    <url>%2F2017%2F07%2F28%2F2017-07-28-emotion-manage%2F</url>
    <content type="text"><![CDATA[分享一篇文章：作者个人对情绪管理上的一些好的建议的总结。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2014/12/06/emotion-manage/ 应对很多事情时情绪都会跑出来作怪，或多或少地影响我对事情的判断，有些时候直接导致了不良结果的发生，所以逐渐形成自己的情绪管理的原则和套路是必要的。 概念情绪管理不是指对情绪的压抑，而是一个逐渐改造自己的应激反应链的过程，让自己面对以前会造成不良情绪的场景，经过一些原则和想法的自我解释与消化，不再产生不良情绪。 建议 因为一件事情跟人争论不休感觉火大打算讥讽对方的时候，脑子里先用一瞬间思考一个问题：这件事情往他（她）意愿的方向发展的结果我真的不能接受吗？也许事情本身怎么发展并不是我关注的重点，我只是觉得按我的想法做才是对的。别人的三观没有义务与你一致，他（她）选择的肯定也是自己认为的最优解，这是别人的自由。为此类事情觉得愤怒和不高兴是不必要的。 当对方因为一件事情给你的明显带着情绪因素的反应的时候，尽量不要也带着情绪去针锋相对，这往往只会让事情更糟。明确你想要让事情向什么方向发展，然后用比争吵更巧妙的方式去推动。 对生活中不能用「非此即彼」定性的问题，排除「这么简单的道理，跟你说了这么久怎么就是讲不通」的想法。每个人有自己不同的处境与成长环境，基于此而形成对同一件事情的不同看法是正常的，无条件地接受这一点。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活这件小事，烦请费思量]]></title>
    <url>%2F2017%2F07%2F27%2F2017-07-27-some-impressions%2F</url>
    <content type="text"><![CDATA[分享一篇文章：生活中不能停止思考，不能沉溺于自己的一方井里成了无知的蛙。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2015/02/01/some-impressions/ 我不生产鸡汤，我只是源自心灵的鸡汤的搬运工。 人都是有惰性的，如果不主动去思考更多，脑子里每天装的仅仅就是工作生活里必须去做的那些事，那逐渐就会麻木了情感，沉溺于身边的一方小世界里成了井底之蛙。 所以—— 做一个有意识的人 要有眼界意识。 眼界决定生活层次，连见都没见过的生活当然不知道怎么努力去过上了。记住这个故事： 两个农妇聊天，其中一个农妇问，你说皇后娘娘早上吃什么？另一个农妇回答：肯定是大饼卷大葱，酱想蘸多少就蘸多少，一点都不心疼；刚好她们的男人也在聊天，一个男人说，如果我是皇帝，就把整个村的牛粪全包下来，不许别人捡，只能我自己一个人捡；另一个人说，愚昧！皇帝哪还用捡牛粪？他老人家肯定是拿个蒲扇，吃着西瓜，坐在树荫底下看着人们捡呢！ 怎么拓宽眼界呢？多经历，多探索，多交流。书本和网络应当成为好工具，与有营养的人交流也能受益匪浅。 当然，当发现自己的能力支撑不了与自己的眼界相匹配的生活的时候，就是该沉淀下来好好学习的时候了。 要有危机意识。 世上能一直保持一成不变的，怕是只有变化本身了吧。既然如此，那生活中的每一环，都存在断裂的可能。想一想自己在某一方面最倚重的，比如经济上最倚重的工作，你的位子坐的真的安稳吗？如果失去它你的生活将何以为继？能否顺利地找到下一个满意的饭碗？ 希望细想之下的你，能够对生活各个方面最倚重的那一环对应的这些问题都自信满满。如果不能，那就想想怎么样能让自己朝那个方向前进。 要有奋斗意识。 有时候觉得自己挺勤奋挺俭省的了，但是细想之下，可能却是如MacTalk里所说的： 学英语学编程是痛苦的，有时候你甚至会有意识地去避免开始这件事情，先干点这个，再干点那个，熬到最后，发现没时间，再拿起来读一会，困了，今天先睡吧。就这样，一天天很快过去了，你发现自己似乎每天都在坚持，但依然没效果。但事实是，你既没坚持，也没效率，这根本不是刻意练习。 不要沉浸在自以为是的励志与悲情里，逆水行舟不进则退，醒醒看看事实： 你花十六块买个便当吃，觉得很节省，有人在路边买了七毛钱馒头吞咽后步履匆匆；你八点起床看书，觉得很勤奋，上朋友圈发现曾经的同学八点就已经在面对繁重的工作；你周六学点新技术，觉得很累，看看微信群才知道许多朋友都连续加班了一个月。亲爱的，你真的还不够苦，不够勤奋和努力。 要有目标意识。 也许你要说，我一直没定过什么长期的目标，日子也就这么过下来了，而且活得也不错啊。 那当然很好，这个时候试着问一句自己，有没有这样的时候：看一眼身边跟自己一起出道的小伙伴，觉得有些人比自己过得好，羡慕嫉妒恨呢？如果没有，那恭喜你，你的幸福指数应该是挺高的（原谅我肤浅地把幸福弄成比较出来的了）。如果有，那可能事实就是，他其实也没有比你努力更多，只是更明确自己要走的路，在你把那么多的努力无意识地散落于生活各方面的时候，他把和你一样多的努力集中铺在了朝特定目标前进的路上。 MORE当然，除了想做一个有意识的人，我还想做一个帅气的人，一个富有的人……]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[眼中的自己]]></title>
    <url>%2F2017%2F07%2F27%2F2017-07-27-myself%2F</url>
    <content type="text"><![CDATA[分享一篇文章：作者对自己优缺点的总结，常回顾以自我提升。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2014/09/27/myself/ 人的一生最大的敌人是自己，最难看清的也是自己。 借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。 优点 可以信任 一般来讲，一件事情如果我应下来，那就会尽力去朝着想要的结果而努力。 热爱阅读 不管有用的没用的，我总是在阅读着，也在进行着一些相应的思考。 缺点 拖延症 任由事情在自己手上堆积，找各种借口不去开始，即使那件事情只需要两分钟就能处理完。 必须症 对自己身上客观存在的一些东西没有无条件地接受；对别人的行为和这个世界的样子存在期待，一旦不符合期待便会焦虑和自我挫败。 含糊症 别人来问我什么问题的时候总是回答得很快，有时候给出的并不是经过思考后最合理最确定的回答，后来反应和发觉过来只好再去补救。其实别人没那么急，略等几秒在脑海里找到确定的答案再答复相对是效率更高的方式，这并不会显得我没有准备和欠思考，实际上它比我立即给出一个不准确的答案而后来再推翻或补充要好。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim-markdown-toc 发布 v1.0 版]]></title>
    <url>%2F2017%2F07%2F26%2F2017-07-26-vim-markdown-toc-release%2F</url>
    <content type="text"><![CDATA[分享一篇文章：原作者自己开发的第一款 Vim 插件的 Release 版本。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2016/10/22/vim-markdown-toc-release/ 前几天，第一款由我独立开发的 Vim 插件 vim-markdown-toc 升级了功能，发布了 v1.0 版本。 它的主要功能是为 Markdown 文件生成 toc（Table of Contents）、更新已经存在的 toc 和在保存时自动更新 toc。 说它是当前使用 Vim 编辑 Markdown 文件时维护 Table of Contents 的最佳解决方案应该不为过。 下载地址 vim-markdown-toc 主要更新 支持使用 :UpdateToc 命令更新已经存在的 toc。 支持保存时自动更新 toc。 功能演示 一些体会 相比于 awesome-adb 的一千多个 Star，vim-markdown-toc 的三十多个 Star 在我心目中含金量更高。 做能挣钱的东西，或者对自己有用的东西。 有天和我们组去年来的小朋友聊天，他说了一个观点我觉得很有道理：做能给自己产生经济效益的东西，你才有动力持续下去。虽然听起来功利，但不无道理。 这么一个插件显然不能挣钱，它属于第二种。本次更新的功能其实在半年前就有网友提过需求，见 #6，但我却迟迟没有动手。半年后的某个夜里，突然就决定要把这些做出来，并且花了几个小时就做完了。究其原因，还是因为自己现在有了需求，我现在要维护几份比较长的 Markdown 文档，如果每次手动去删除已有 toc 然后再次生成，虽然比纯手工写 toc 要不知道方便和准确到哪里去了，但归根结底还是不够完美。果然最后用着自己做的功能替自己省下不少重复劳动时，那种感觉也是很爽的。 酒香也怕巷子深。 发布了个人的项目后，适当地在相关的社区进行推广，让更多的人享受到你的劳动成果，帮助验证和反馈，也能给自己带来更多的成就感和关注度。]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 Markdown 生成 TOC 的 Vim 插件]]></title>
    <url>%2F2017%2F07%2F25%2F2017-07-25-vim-markdown-toc%2F</url>
    <content type="text"><![CDATA[分享一篇文章：为 Markdown 自动生成 Table of Contents 的 Vim 插件 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2015/12/19/vim-markdown-toc/ 因为饱受 GFM 和 Redcarpet 两种 Markdown 引擎生成 TOC 链接的差异的折磨，而我又不得不同时使用它们——博客基于 Jekyll 使用 Redcarpet（Update 2016/09/16: GitHub Pages 现在已经改为只支持 kramdown），而其它放在 GitHub 仓库里的文档使用 GFM，我决定为我常用的 Markdown 编辑器 Vim 做一款同时支持 GFM 和 Redcarpet 两种 TOC 链接风格的 Table of Contents 自动生成插件。 这算是我真正意义上完全独立开发的第一款实用 Vim 插件，当然开发过程中也参考了别人的做法。 下载地址 vim-markdown-toc 功能 为 Markdown 文件生成 Table of Contents，目前支持 GFM 和 Redcarpet 两种链接风格。 更新已经存在的 Table of Contents。 保存文件时自动更新 Table of Contents。 使用方法生成 Table of Contents将光标移动到想在后面插入 Table of Contents 的那一行，然后运行下面的某个命令： :GenTocGFM 生成 GFM 链接风格的 Table of Contents。 适用于 GitHub 仓库里的 Markdown 文件，比如 README.md，也适用用于生成 GitBook 的 Markdown 文件。 :GenTocRedcarpet 生成 Redcarpet 链接风格的 Table of Contents。 适用于使用 Redcarpet 作为 Markdown 引擎的 Jekyll 项目或其它地方。 更新已存在的 Table of Contents通常不需要手动做这件事，保存文件时会自动更新已经存在的 Table of Contents。 除非是在配置里关闭了保存时自动更新，并且维持插入 Table of Contents 前后的 &lt;!-- vim-markdown-toc --&gt;，此时可使用 :UpdateToc 命令手动更新。 安装方法推荐使用 Vundle 来管理你的 Vim 插件，这样你就可以简单三步完成安装： 在你的 vimrc 文件中添加如下内容： 1Plugin &apos;mzlogin/vim-markdown-toc&apos; :so $MYVIMRC :PluginInstall 使用 vim-plug 安装的过程的与此基本一样。 配置选项 g:vmt_auto_update_on_save 默认值：1 插件会自动更新已经存在的 Table of Contents，如果你不想要这个功能，可以在你的 vimrc 文件里加入如下内容关闭： 1let g:vmt_auto_update_on_save = 0 g:vmt_dont_insert_fence 默认值：0 在默认情况下，:GenTocXXX 命令会在插入的 Table of Contents 前后加上 &lt;!-- vim-markdown-toc --&gt;，这是为了实现自动和手动更新 Table of Contents 功能。 如果你不想看到它们，可以在 vimrc 文件里加入如下内容移除： 1let g:vmt_dont_insert_fence = 1 需要注意的是移除之后插件将无法再帮你保存文件时自动更新 Table of Contents 了，也无法使用 :UpdateToc 命令了。这里如果还想更新 Table of Contents，只能先手动删除已经存在的，然后重新运行 :GenTocXXX 命令。 g:vmt_cycle_list_item_markers 默认值：0 在默认情况下，所有 Table of Contents 项目前面的标记都是 *： 12345* [Level 1](#level-1) * [Level 1-1](#level-1-1) * [Level 1-2](#level-1-2) * [Level 1-2-1](#level-1-2-1)* [Level 2](level-2) 这里提供一个选项改变这个行为，如果设置： 1let g:vmt_cycle_list_item_markers = 1 那标记将根据级别循环使用 *、- 和 +： 12345* [Level 1](#level-1) - [Level 1-1](#level-1-1) - [Level 1-2](#level-1-2) + [Level 1-2-1](#level-1-2-1)* [Level 2](level-2) 这不会影响 Markdown 文档解析后的显示效果，只用于提升源文件的可读性。 屏幕截图使用本插件生成 TOC 的英文文档在线示例 使用本插件生成 TOC 的中文文档在线示例 参考链接 GFM 与 Redcarpet 的不同点 ajorgensen/vim-markdown-toc]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的生活]]></title>
    <url>%2F2017%2F07%2F25%2F2017-07-26-aboutlife%2F</url>
    <content type="text"><![CDATA[分享一篇文章：作者自己对生活的理解，认识上有改变就更新在这里。 原文作者：Zhuang Ma原文链接地址：http://mazhuang.org/2014/08/30/aboutlife/ 每一次「嘴笨」的背后，都有平时疏于思考的懒惰。——写在最前面。 我想要什么这个可以分两个方面来讲：物质和精神。 从物质上来讲，我期望能够尽快地拥有世俗眼光里大家认为这个年纪的生活里应该拥有的东西，直白点讲就是车子房子票子妹子（排名不分先后）。 从精神上来讲，我目前比较想的是不久后的某一天，我能惊喜地发现自己已经克服了「必须症」。 急功近利，焦虑不安，是现状。除了特别年幼的那几年，从小到大，一直在学也没学好玩也没玩好的怪圈里挣扎，到如今自认为是循规蹈矩，个性全无。但其实细想一下，我们到底在急什么？大学毕业参加工作才几年时光，就迫不及待地想拥有一切。我们一直在匆忙前行，其实最急迫的可能不是快点往前走，而是偶尔停下来想一想为何这样，调整好前进的方向。 关于爱情一个人的时候其实是很无畏很能凑合的，是爱让我懂得害怕，害怕失去，害怕在她面前表现得不够好，害怕不能给她好的生活。 两个人免不了要彼此包容，想要在所有事情上都观点相同是不现实的；两个人应该也要能彼此成就，能有一些促进对方做更好的自己的特质。 当然最重要的，我们首先还是自己的自己，然后才会是彼此的彼此，每个人都应该活出一个丰满充实的人生，不应把自己的愉悦与幸福过度地寄托在别人身上，幸福是自己感觉出来的。 任何事情说得太多了就廉价了，比如说爱，比如表白。 关于承诺一直以来都认为爱情里的承诺是一种很苍白的语言。双方足够信任的时候，不需要承诺，因为会笃定地相信两个人会为了共同的目标去努力。在不得不需要承诺来令对方相信的时候，相信两个人心里都会有一丝悲情和哀伤。 如果必须要承诺，我承诺我会持续不断地努力让自己和爱的人生活得更好。 关于欲望欲望是无止境的，很多东西，够用舒适就行，在这样的前提下，容易满足的人更容易得到更多的幸福感吧。]]></content>
      <categories>
        <category>朝花惜拾</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[It’s me于千万人之中遇见你所要遇见的人， 于千万年之中，时间的无涯的荒野里， 没有早一步，也没有晚一步，刚巧赶上了， 那也没有别的话可说，惟有轻轻地问一声： “噢，你也在这里吗？” —— 张爱玲 《爱》 我，一个不负流年，不负自己的前端程序员。创立此博客网站，是我大二暑假前期。目的是记录、总结自己的学习过程，分享、帮助像我一样学习前端及其他编程技术的学习建议参考，互相学习、一起进步，欢迎指正。 我一直坚信学习的技巧是动手，学习的灵魂是坚持，学习的态度是务实，学习的快乐是分享。从学习编程技术开始，一直摸爬滚打，四处碰壁的勇敢前行着，我没有编程的天赋，没有超乎常人的智商，没有前辈指导，一路学习过来，大部分都是心酸的过程，但是我无怨无悔，我知道自己没有别人聪明，也没有别人条件好。只能靠自己拼搏，靠自己无畏的前行。我就想在自己喜欢的领域，创造属于自己的小世界。我不怕辛苦，习惯了一个人的孤独，但有时候，真的会很烦， 没办法，想找到志同道合的人一起奋斗，真的、真的很难。但是，我相信自己，每天不断的学习，一定会成为前端大神，一定会在IT行业中有所作为，别忘了，我是有梦想的人！很喜欢的一句话： 年轻的时候就能找到自己喜欢并且干一辈子的事情是多么幸福多么令人羡慕啊。 不管未来怎么样，我想要成为前端高级开发工程师。为了这个梦想，而努力奋斗的少年！唯愿一路风清，且行且珍惜。我一直在Coding…]]></content>
  </entry>
  <entry>
    <title><![CDATA[所有分类汇总]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[所有标签汇总]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
